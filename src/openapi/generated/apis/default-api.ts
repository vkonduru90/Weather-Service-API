/* tslint:disable */
/* eslint-disable */
/**
 * weather.gov API
 * weather.gov API
 *
 * The version of the OpenAPI document: 3.3.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { AlertAtomFeed } from '../models';
// @ts-ignore
import type { AlertCertainty } from '../models';
// @ts-ignore
import type { AlertCollectionGeoJson } from '../models';
// @ts-ignore
import type { AlertCollectionJsonLd } from '../models';
// @ts-ignore
import type { AlertGeoJson } from '../models';
// @ts-ignore
import type { AlertJsonLd } from '../models';
// @ts-ignore
import type { AlertSeverity } from '../models';
// @ts-ignore
import type { AlertUrgency } from '../models';
// @ts-ignore
import type { AlertsActiveCount200Response } from '../models';
// @ts-ignore
import type { AlertsTypes200Response } from '../models';
// @ts-ignore
import type { AreaCode } from '../models';
// @ts-ignore
import type { CenterWeatherAdvisoryCollectionGeoJson } from '../models';
// @ts-ignore
import type { CenterWeatherAdvisoryGeoJson } from '../models';
// @ts-ignore
import type { Glossary200Response } from '../models';
// @ts-ignore
import type { Gridpoint } from '../models';
// @ts-ignore
import type { Gridpoint12hForecastGeoJson } from '../models';
// @ts-ignore
import type { Gridpoint12hForecastJsonLd } from '../models';
// @ts-ignore
import type { GridpointForecastUnits } from '../models';
// @ts-ignore
import type { GridpointGeoJson } from '../models';
// @ts-ignore
import type { GridpointHourlyForecastGeoJson } from '../models';
// @ts-ignore
import type { GridpointHourlyForecastJsonLd } from '../models';
// @ts-ignore
import type { ISO8601Interval } from '../models';
// @ts-ignore
import type { IconsSizeParameter } from '../models';
// @ts-ignore
import type { IconsSummary200Response } from '../models';
// @ts-ignore
import type { MarineRegionCode } from '../models';
// @ts-ignore
import type { NWSCenterWeatherServiceUnitId } from '../models';
// @ts-ignore
import type { NWSForecastOfficeId } from '../models';
// @ts-ignore
import type { NWSOfficeId } from '../models';
// @ts-ignore
import type { NWSZoneType } from '../models';
// @ts-ignore
import type { Observation } from '../models';
// @ts-ignore
import type { ObservationCollectionGeoJson } from '../models';
// @ts-ignore
import type { ObservationCollectionJsonLd } from '../models';
// @ts-ignore
import type { ObservationGeoJson } from '../models';
// @ts-ignore
import type { ObservationStationCollectionGeoJson } from '../models';
// @ts-ignore
import type { ObservationStationCollectionJsonLd } from '../models';
// @ts-ignore
import type { ObservationStationGeoJson } from '../models';
// @ts-ignore
import type { ObservationStationJsonLd } from '../models';
// @ts-ignore
import type { Office } from '../models';
// @ts-ignore
import type { OfficeHeadline } from '../models';
// @ts-ignore
import type { OfficeHeadlineCollection } from '../models';
// @ts-ignore
import type { PointGeoJson } from '../models';
// @ts-ignore
import type { PointJsonLd } from '../models';
// @ts-ignore
import type { ProblemDetail } from '../models';
// @ts-ignore
import type { RegionCode } from '../models';
// @ts-ignore
import type { SigmetCollectionGeoJson } from '../models';
// @ts-ignore
import type { SigmetGeoJson } from '../models';
// @ts-ignore
import type { TextProduct } from '../models';
// @ts-ignore
import type { TextProductCollection } from '../models';
// @ts-ignore
import type { TextProductLocationCollection } from '../models';
// @ts-ignore
import type { TextProductTypeCollection } from '../models';
// @ts-ignore
import type { Zone } from '../models';
// @ts-ignore
import type { ZoneCollectionGeoJson } from '../models';
// @ts-ignore
import type { ZoneCollectionJsonLd } from '../models';
// @ts-ignore
import type { ZoneForecast } from '../models';
// @ts-ignore
import type { ZoneForecastGeoJson } from '../models';
// @ts-ignore
import type { ZoneGeoJson } from '../models';
/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all currently active alerts
         * @param {Array<AlertsActiveStatusEnum>} [status] Status (actual, exercise, system, test, draft)
         * @param {Array<AlertsActiveMessageTypeEnum>} [messageType] Message type (alert, update, cancel)
         * @param {Array<string>} [event] Event name
         * @param {Array<string>} [code] Event code
         * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
         * @param {string} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
         * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
         * @param {AlertsActiveRegionTypeEnum} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
         * @param {Array<string>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
         * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
         * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
         * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActive: async (status?: Array<AlertsActiveStatusEnum>, messageType?: Array<AlertsActiveMessageTypeEnum>, event?: Array<string>, code?: Array<string>, area?: Array<AreaCode>, point?: string, region?: Array<MarineRegionCode>, regionType?: AlertsActiveRegionTypeEnum, zone?: Array<string>, urgency?: Array<AlertUrgency>, severity?: Array<AlertSeverity>, certainty?: Array<AlertCertainty>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alerts/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS.csv);
            }

            if (messageType) {
                localVarQueryParameter['message_type'] = messageType.join(COLLECTION_FORMATS.csv);
            }

            if (event) {
                localVarQueryParameter['event'] = event.join(COLLECTION_FORMATS.csv);
            }

            if (code) {
                localVarQueryParameter['code'] = code.join(COLLECTION_FORMATS.csv);
            }

            if (area) {
                localVarQueryParameter['area'] = area.join(COLLECTION_FORMATS.csv);
            }

            if (point !== undefined) {
                localVarQueryParameter['point'] = point;
            }

            if (region) {
                localVarQueryParameter['region'] = region.join(COLLECTION_FORMATS.csv);
            }

            if (regionType !== undefined) {
                localVarQueryParameter['region_type'] = regionType;
            }

            if (zone) {
                localVarQueryParameter['zone'] = zone.join(COLLECTION_FORMATS.csv);
            }

            if (urgency) {
                localVarQueryParameter['urgency'] = urgency.join(COLLECTION_FORMATS.csv);
            }

            if (severity) {
                localVarQueryParameter['severity'] = severity.join(COLLECTION_FORMATS.csv);
            }

            if (certainty) {
                localVarQueryParameter['certainty'] = certainty.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns active alerts for the given area (state or marine area)
         * @param {AreaCode} area State/area ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActiveArea: async (area: AreaCode, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'area' is not null or undefined
            assertParamExists('alertsActiveArea', 'area', area)
            const localVarPath = `/alerts/active/area/{area}`
                .replace(`{${"area"}}`, encodeURIComponent(String(area)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns info on the number of active alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActiveCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alerts/active/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns active alerts for the given marine region
         * @param {MarineRegionCode} region Marine region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActiveRegion: async (region: MarineRegionCode, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('alertsActiveRegion', 'region', region)
            const localVarPath = `/alerts/active/region/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns active alerts for the given NWS public zone or county
         * @param {string} zoneId NWS public zone/county identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActiveZone: async (zoneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('alertsActiveZone', 'zoneId', zoneId)
            const localVarPath = `/alerts/active/zone/{zoneId}`
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all alerts
         * @param {boolean} [active] List only active alerts (use /alerts/active endpoints instead)
         * @param {string} [start] Start time
         * @param {string} [end] End time
         * @param {Array<AlertsQueryStatusEnum>} [status] Status (actual, exercise, system, test, draft)
         * @param {Array<AlertsQueryMessageTypeEnum>} [messageType] Message type (alert, update, cancel)
         * @param {Array<string>} [event] Event name
         * @param {Array<string>} [code] Event code
         * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
         * @param {string} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
         * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
         * @param {AlertsQueryRegionTypeEnum} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
         * @param {Array<string>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
         * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
         * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
         * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
         * @param {number} [limit] Limit
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsQuery: async (active?: boolean, start?: string, end?: string, status?: Array<AlertsQueryStatusEnum>, messageType?: Array<AlertsQueryMessageTypeEnum>, event?: Array<string>, code?: Array<string>, area?: Array<AreaCode>, point?: string, region?: Array<MarineRegionCode>, regionType?: AlertsQueryRegionTypeEnum, zone?: Array<string>, urgency?: Array<AlertUrgency>, severity?: Array<AlertSeverity>, certainty?: Array<AlertCertainty>, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS.csv);
            }

            if (messageType) {
                localVarQueryParameter['message_type'] = messageType.join(COLLECTION_FORMATS.csv);
            }

            if (event) {
                localVarQueryParameter['event'] = event.join(COLLECTION_FORMATS.csv);
            }

            if (code) {
                localVarQueryParameter['code'] = code.join(COLLECTION_FORMATS.csv);
            }

            if (area) {
                localVarQueryParameter['area'] = area.join(COLLECTION_FORMATS.csv);
            }

            if (point !== undefined) {
                localVarQueryParameter['point'] = point;
            }

            if (region) {
                localVarQueryParameter['region'] = region.join(COLLECTION_FORMATS.csv);
            }

            if (regionType !== undefined) {
                localVarQueryParameter['region_type'] = regionType;
            }

            if (zone) {
                localVarQueryParameter['zone'] = zone.join(COLLECTION_FORMATS.csv);
            }

            if (urgency) {
                localVarQueryParameter['urgency'] = urgency.join(COLLECTION_FORMATS.csv);
            }

            if (severity) {
                localVarQueryParameter['severity'] = severity.join(COLLECTION_FORMATS.csv);
            }

            if (certainty) {
                localVarQueryParameter['certainty'] = certainty.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific alert
         * @param {string} id Alert identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsSingle: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertsSingle', 'id', id)
            const localVarPath = `/alerts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of alert types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alerts/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Center Weather Advisories from a CWSU
         * @param {NWSCenterWeatherServiceUnitId} cwsuId NWS CWSU ID
         * @param {string} date Date (YYYY-MM-DD format)
         * @param {number} sequence Sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwa: async (cwsuId: NWSCenterWeatherServiceUnitId, date: string, sequence: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cwsuId' is not null or undefined
            assertParamExists('cwa', 'cwsuId', cwsuId)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('cwa', 'date', date)
            // verify required parameter 'sequence' is not null or undefined
            assertParamExists('cwa', 'sequence', sequence)
            const localVarPath = `/aviation/cwsus/{cwsuId}/cwas/{date}/{sequence}`
                .replace(`{${"cwsuId"}}`, encodeURIComponent(String(cwsuId)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)))
                .replace(`{${"sequence"}}`, encodeURIComponent(String(sequence)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Center Weather Advisories from a CWSU
         * @param {NWSCenterWeatherServiceUnitId} cwsuId NWS CWSU ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwas: async (cwsuId: NWSCenterWeatherServiceUnitId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cwsuId' is not null or undefined
            assertParamExists('cwas', 'cwsuId', cwsuId)
            const localVarPath = `/aviation/cwsus/{cwsuId}/cwas`
                .replace(`{${"cwsuId"}}`, encodeURIComponent(String(cwsuId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a Center Weather Service Unit
         * @param {NWSCenterWeatherServiceUnitId} cwsuId NWS CWSU ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwsu: async (cwsuId: NWSCenterWeatherServiceUnitId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cwsuId' is not null or undefined
            assertParamExists('cwsu', 'cwsuId', cwsuId)
            const localVarPath = `/aviation/cwsus/{cwsuId}`
                .replace(`{${"cwsuId"}}`, encodeURIComponent(String(cwsuId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns glossary terms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/glossary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns raw numerical forecast data for a 2.5km grid area
         * @param {NWSForecastOfficeId} wfo Forecast office ID
         * @param {number} x Forecast grid X coordinate
         * @param {number} y Forecast grid Y coordinate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridpoint: async (wfo: NWSForecastOfficeId, x: number, y: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wfo' is not null or undefined
            assertParamExists('gridpoint', 'wfo', wfo)
            // verify required parameter 'x' is not null or undefined
            assertParamExists('gridpoint', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('gridpoint', 'y', y)
            const localVarPath = `/gridpoints/{wfo}/{x},{y}`
                .replace(`{${"wfo"}}`, encodeURIComponent(String(wfo)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a textual forecast for a 2.5km grid area
         * @param {NWSForecastOfficeId} wfo Forecast office ID
         * @param {number} x Forecast grid X coordinate
         * @param {number} y Forecast grid Y coordinate
         * @param {Array<GridpointForecastFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
         * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridpointForecast: async (wfo: NWSForecastOfficeId, x: number, y: number, featureFlags?: Array<GridpointForecastFeatureFlagsEnum>, units?: GridpointForecastUnits, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wfo' is not null or undefined
            assertParamExists('gridpointForecast', 'wfo', wfo)
            // verify required parameter 'x' is not null or undefined
            assertParamExists('gridpointForecast', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('gridpointForecast', 'y', y)
            const localVarPath = `/gridpoints/{wfo}/{x},{y}/forecast`
                .replace(`{${"wfo"}}`, encodeURIComponent(String(wfo)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }


    
            if (featureFlags) {
                let mapped = featureFlags.map(value => (<any>"Array<'forecast_temperature_qv' | 'forecast_wind_speed_qv'>" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
                localVarHeaderParameter['Feature-Flags'] = mapped.join(COLLECTION_FORMATS["csv"]);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a textual hourly forecast for a 2.5km grid area
         * @param {NWSForecastOfficeId} wfo Forecast office ID
         * @param {number} x Forecast grid X coordinate
         * @param {number} y Forecast grid Y coordinate
         * @param {Array<GridpointForecastHourlyFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
         * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridpointForecastHourly: async (wfo: NWSForecastOfficeId, x: number, y: number, featureFlags?: Array<GridpointForecastHourlyFeatureFlagsEnum>, units?: GridpointForecastUnits, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wfo' is not null or undefined
            assertParamExists('gridpointForecastHourly', 'wfo', wfo)
            // verify required parameter 'x' is not null or undefined
            assertParamExists('gridpointForecastHourly', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('gridpointForecastHourly', 'y', y)
            const localVarPath = `/gridpoints/{wfo}/{x},{y}/forecast/hourly`
                .replace(`{${"wfo"}}`, encodeURIComponent(String(wfo)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }


    
            if (featureFlags) {
                let mapped = featureFlags.map(value => (<any>"Array<'forecast_temperature_qv' | 'forecast_wind_speed_qv'>" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
                localVarHeaderParameter['Feature-Flags'] = mapped.join(COLLECTION_FORMATS["csv"]);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of observation stations usable for a given 2.5km grid area
         * @param {NWSForecastOfficeId} wfo Forecast office ID
         * @param {number} x Forecast grid X coordinate
         * @param {number} y Forecast grid Y coordinate
         * @param {number} [limit] Limit
         * @param {Array<GridpointStationsFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridpointStations: async (wfo: NWSForecastOfficeId, x: number, y: number, limit?: number, featureFlags?: Array<GridpointStationsFeatureFlagsEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wfo' is not null or undefined
            assertParamExists('gridpointStations', 'wfo', wfo)
            // verify required parameter 'x' is not null or undefined
            assertParamExists('gridpointStations', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('gridpointStations', 'y', y)
            const localVarPath = `/gridpoints/{wfo}/{x},{y}/stations`
                .replace(`{${"wfo"}}`, encodeURIComponent(String(wfo)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (featureFlags) {
                let mapped = featureFlags.map(value => (<any>"Array<'obs_station_provider'>" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
                localVarHeaderParameter['Feature-Flags'] = mapped.join(COLLECTION_FORMATS["csv"]);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a forecast icon. Icon services in API are deprecated.
         * @param {string} set .
         * @param {string} timeOfDay .
         * @param {string} first .
         * @param {IconsSizeParameter} [size] Font size
         * @param {number} [fontsize] Font size
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        icons: async (set: string, timeOfDay: string, first: string, size?: IconsSizeParameter, fontsize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'set' is not null or undefined
            assertParamExists('icons', 'set', set)
            // verify required parameter 'timeOfDay' is not null or undefined
            assertParamExists('icons', 'timeOfDay', timeOfDay)
            // verify required parameter 'first' is not null or undefined
            assertParamExists('icons', 'first', first)
            const localVarPath = `/icons/{set}/{timeOfDay}/{first}`
                .replace(`{${"set"}}`, encodeURIComponent(String(set)))
                .replace(`{${"timeOfDay"}}`, encodeURIComponent(String(timeOfDay)))
                .replace(`{${"first"}}`, encodeURIComponent(String(first)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (size !== undefined) {
                for (const [key, value] of Object.entries(size)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (fontsize !== undefined) {
                localVarQueryParameter['fontsize'] = fontsize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a forecast icon. Icon services in API are deprecated.
         * @param {string} set .
         * @param {string} timeOfDay .
         * @param {string} first .
         * @param {string} second .
         * @param {IconsSizeParameter} [size] Font size
         * @param {number} [fontsize] Font size
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iconsDualCondition: async (set: string, timeOfDay: string, first: string, second: string, size?: IconsSizeParameter, fontsize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'set' is not null or undefined
            assertParamExists('iconsDualCondition', 'set', set)
            // verify required parameter 'timeOfDay' is not null or undefined
            assertParamExists('iconsDualCondition', 'timeOfDay', timeOfDay)
            // verify required parameter 'first' is not null or undefined
            assertParamExists('iconsDualCondition', 'first', first)
            // verify required parameter 'second' is not null or undefined
            assertParamExists('iconsDualCondition', 'second', second)
            const localVarPath = `/icons/{set}/{timeOfDay}/{first}/{second}`
                .replace(`{${"set"}}`, encodeURIComponent(String(set)))
                .replace(`{${"timeOfDay"}}`, encodeURIComponent(String(timeOfDay)))
                .replace(`{${"first"}}`, encodeURIComponent(String(first)))
                .replace(`{${"second"}}`, encodeURIComponent(String(second)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (size !== undefined) {
                for (const [key, value] of Object.entries(size)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (fontsize !== undefined) {
                localVarQueryParameter['fontsize'] = fontsize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iconsSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/icons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns latest text products of a given type for a given issuance location with product text
         * @param {string} typeId .
         * @param {string} locationId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        latestProductTypeLocation: async (typeId: string, locationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeId' is not null or undefined
            assertParamExists('latestProductTypeLocation', 'typeId', typeId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('latestProductTypeLocation', 'locationId', locationId)
            const localVarPath = `/products/types/{typeId}/locations/{locationId}/latest`
                .replace(`{${"typeId"}}`, encodeURIComponent(String(typeId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of valid text product types for a given issuance location
         * @param {string} locationId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationProducts: async (locationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('locationProducts', 'locationId', locationId)
            const localVarPath = `/products/locations/{locationId}/types`
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a given observation station
         * @param {string} stationId Observation station ID
         * @param {Array<ObsStationFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obsStation: async (stationId: string, featureFlags?: Array<ObsStationFeatureFlagsEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('obsStation', 'stationId', stationId)
            const localVarPath = `/stations/{stationId}`
                .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            if (featureFlags) {
                let mapped = featureFlags.map(value => (<any>"Array<'obs_station_provider'>" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
                localVarHeaderParameter['Feature-Flags'] = mapped.join(COLLECTION_FORMATS["csv"]);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of observation stations.
         * @param {Array<string>} [id] Filter by observation station ID
         * @param {Array<AreaCode>} [state] Filter by state/marine area code
         * @param {number} [limit] Limit
         * @param {string} [cursor] Pagination cursor
         * @param {Array<ObsStationsFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obsStations: async (id?: Array<string>, state?: Array<AreaCode>, limit?: number, cursor?: string, featureFlags?: Array<ObsStationsFeatureFlagsEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }

            if (state) {
                localVarQueryParameter['state'] = state.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            if (featureFlags) {
                let mapped = featureFlags.map(value => (<any>"Array<'obs_station_provider'>" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
                localVarHeaderParameter['Feature-Flags'] = mapped.join(COLLECTION_FORMATS["csv"]);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a NWS forecast office
         * @param {NWSOfficeId} officeId NWS office ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        office: async (officeId: NWSOfficeId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'officeId' is not null or undefined
            assertParamExists('office', 'officeId', officeId)
            const localVarPath = `/offices/{officeId}`
                .replace(`{${"officeId"}}`, encodeURIComponent(String(officeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific news headline for a given NWS office
         * @param {NWSOfficeId} officeId NWS office ID
         * @param {string} headlineId Headline record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        officeHeadline: async (officeId: NWSOfficeId, headlineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'officeId' is not null or undefined
            assertParamExists('officeHeadline', 'officeId', officeId)
            // verify required parameter 'headlineId' is not null or undefined
            assertParamExists('officeHeadline', 'headlineId', headlineId)
            const localVarPath = `/offices/{officeId}/headlines/{headlineId}`
                .replace(`{${"officeId"}}`, encodeURIComponent(String(officeId)))
                .replace(`{${"headlineId"}}`, encodeURIComponent(String(headlineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of news headlines for a given NWS office
         * @param {NWSOfficeId} officeId NWS office ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        officeHeadlines: async (officeId: NWSOfficeId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'officeId' is not null or undefined
            assertParamExists('officeHeadlines', 'officeId', officeId)
            const localVarPath = `/offices/{officeId}/headlines`
                .replace(`{${"officeId"}}`, encodeURIComponent(String(officeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a given latitude/longitude point
         * @param {number} latitude Latitude
         * @param {number} longitude Longitude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        point: async (latitude: number, longitude: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('point', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('point', 'longitude', longitude)
            const localVarPath = `/points/{latitude},{longitude}`
                .replace(`{${"latitude"}}`, encodeURIComponent(String(latitude)))
                .replace(`{${"longitude"}}`, encodeURIComponent(String(longitude)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns NOAA Weather Radio script for a latitude/longitude point
         * @param {number} latitude Latitude
         * @param {number} longitude Longitude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointRadio: async (latitude: number, longitude: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('pointRadio', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('pointRadio', 'longitude', longitude)
            const localVarPath = `/points/{latitude},{longitude}/radio`
                .replace(`{${"latitude"}}`, encodeURIComponent(String(latitude)))
                .replace(`{${"longitude"}}`, encodeURIComponent(String(longitude)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of observation stations for a given point
         * @param {number} latitude Latitude
         * @param {number} longitude Longitude
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        pointStations: async (latitude: number, longitude: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('pointStations', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('pointStations', 'longitude', longitude)
            const localVarPath = `/points/{latitude},{longitude}/stations`
                .replace(`{${"latitude"}}`, encodeURIComponent(String(latitude)))
                .replace(`{${"longitude"}}`, encodeURIComponent(String(longitude)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific text product
         * @param {string} productId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        product: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('product', 'productId', productId)
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of valid text product issuance locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productLocations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of valid text product types and codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of text products
         * @param {Array<string>} [location] Location id
         * @param {string} [start] Start time
         * @param {string} [end] End time
         * @param {Array<string>} [office] Issuing office
         * @param {Array<string>} [wmoid] WMO id code
         * @param {Array<string>} [type] Product code
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsQuery: async (location?: Array<string>, start?: string, end?: string, office?: Array<string>, wmoid?: Array<string>, type?: Array<string>, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (location) {
                localVarQueryParameter['location'] = location.join(COLLECTION_FORMATS.csv);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (office) {
                localVarQueryParameter['office'] = office.join(COLLECTION_FORMATS.csv);
            }

            if (wmoid) {
                localVarQueryParameter['wmoid'] = wmoid.join(COLLECTION_FORMATS.csv);
            }

            if (type) {
                localVarQueryParameter['type'] = type.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of text products of a given type
         * @param {string} typeId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsType: async (typeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeId' is not null or undefined
            assertParamExists('productsType', 'typeId', typeId)
            const localVarPath = `/products/types/{typeId}`
                .replace(`{${"typeId"}}`, encodeURIComponent(String(typeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of text products of a given type for a given issuance location
         * @param {string} typeId .
         * @param {string} locationId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsTypeLocation: async (typeId: string, locationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeId' is not null or undefined
            assertParamExists('productsTypeLocation', 'typeId', typeId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('productsTypeLocation', 'locationId', locationId)
            const localVarPath = `/products/types/{typeId}/locations/{locationId}`
                .replace(`{${"typeId"}}`, encodeURIComponent(String(typeId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of valid text product issuance locations for a given product type
         * @param {string} typeId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsTypeLocations: async (typeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeId' is not null or undefined
            assertParamExists('productsTypeLocations', 'typeId', typeId)
            const localVarPath = `/products/types/{typeId}/locations`
                .replace(`{${"typeId"}}`, encodeURIComponent(String(typeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a given radar wind profiler
         * @param {string} stationId Profiler station ID
         * @param {ISO8601Interval} [time] Time interval
         * @param {string} [interval] Averaging interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarProfiler: async (stationId: string, time?: ISO8601Interval, interval?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('radarProfiler', 'stationId', stationId)
            const localVarPath = `/radar/profilers/{stationId}`
                .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (time !== undefined) {
                for (const [key, value] of Object.entries(time)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a given radar queue
         * @param {string} host LDM host
         * @param {number} [limit] Record limit
         * @param {ISO8601Interval} [arrived] Range for arrival time
         * @param {ISO8601Interval} [created] Range for creation time
         * @param {ISO8601Interval} [published] Range for publish time
         * @param {string} [station] Station identifier
         * @param {string} [type] Record type
         * @param {string} [feed] Originating product feed
         * @param {number} [resolution] Resolution version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarQueue: async (host: string, limit?: number, arrived?: ISO8601Interval, created?: ISO8601Interval, published?: ISO8601Interval, station?: string, type?: string, feed?: string, resolution?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'host' is not null or undefined
            assertParamExists('radarQueue', 'host', host)
            const localVarPath = `/radar/queues/{host}`
                .replace(`{${"host"}}`, encodeURIComponent(String(host)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (arrived !== undefined) {
                for (const [key, value] of Object.entries(arrived)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (created !== undefined) {
                for (const [key, value] of Object.entries(created)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (published !== undefined) {
                for (const [key, value] of Object.entries(published)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (station !== undefined) {
                localVarQueryParameter['station'] = station;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (feed !== undefined) {
                localVarQueryParameter['feed'] = feed;
            }

            if (resolution !== undefined) {
                localVarQueryParameter['resolution'] = resolution;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a given radar server
         * @param {string} id Server ID
         * @param {string} [reportingHost] Show records from specific reporting host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarServer: async (id: string, reportingHost?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('radarServer', 'id', id)
            const localVarPath = `/radar/servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (reportingHost !== undefined) {
                localVarQueryParameter['reportingHost'] = reportingHost;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of radar servers
         * @param {string} [reportingHost] Show records from specific reporting host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarServers: async (reportingHost?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (reportingHost !== undefined) {
                localVarQueryParameter['reportingHost'] = reportingHost;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a given radar station
         * @param {string} stationId Radar station ID
         * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
         * @param {string} [host] Show latency info from specific LDM host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarStation: async (stationId: string, reportingHost?: string, host?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('radarStation', 'stationId', stationId)
            const localVarPath = `/radar/stations/{stationId}`
                .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (reportingHost !== undefined) {
                localVarQueryParameter['reportingHost'] = reportingHost;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a given radar station alarms
         * @param {string} stationId Radar station ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarStationAlarms: async (stationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('radarStationAlarms', 'stationId', stationId)
            const localVarPath = `/radar/stations/{stationId}/alarms`
                .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of radar stations
         * @param {Array<string>} [stationType] Limit results to a specific station type or types
         * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
         * @param {string} [host] Show latency info from specific LDM host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarStations: async (stationType?: Array<string>, reportingHost?: string, host?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/stations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (stationType) {
                localVarQueryParameter['stationType'] = stationType.join(COLLECTION_FORMATS.csv);
            }

            if (reportingHost !== undefined) {
                localVarQueryParameter['reportingHost'] = reportingHost;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
         * @param {SatelliteThumbnailsAreaEnum} area .
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        satelliteThumbnails: async (area: SatelliteThumbnailsAreaEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'area' is not null or undefined
            assertParamExists('satelliteThumbnails', 'area', area)
            const localVarPath = `/thumbnails/satellite/{area}`
                .replace(`{${"area"}}`, encodeURIComponent(String(area)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific SIGMET/AIRMET
         * @param {string} atsu ATSU identifier
         * @param {string} date Date (YYYY-MM-DD format)
         * @param {string} time Time (HHMM format). This time is always specified in UTC (Zulu) time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sigmet: async (atsu: string, date: string, time: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'atsu' is not null or undefined
            assertParamExists('sigmet', 'atsu', atsu)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('sigmet', 'date', date)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('sigmet', 'time', time)
            const localVarPath = `/aviation/sigmets/{atsu}/{date}/{time}`
                .replace(`{${"atsu"}}`, encodeURIComponent(String(atsu)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)))
                .replace(`{${"time"}}`, encodeURIComponent(String(time)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of SIGMET/AIRMETs
         * @param {string} [start] Start time
         * @param {string} [end] End time
         * @param {string} [date] Date (YYYY-MM-DD format)
         * @param {string} [atsu] ATSU identifier
         * @param {string} [sequence] SIGMET sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sigmetQuery: async (start?: string, end?: string, date?: string, atsu?: string, sequence?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aviation/sigmets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (atsu !== undefined) {
                localVarQueryParameter['atsu'] = atsu;
            }

            if (sequence !== undefined) {
                localVarQueryParameter['sequence'] = sequence;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of SIGMET/AIRMETs for the specified ATSU
         * @param {string} atsu ATSU identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sigmetsByATSU: async (atsu: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'atsu' is not null or undefined
            assertParamExists('sigmetsByATSU', 'atsu', atsu)
            const localVarPath = `/aviation/sigmets/{atsu}`
                .replace(`{${"atsu"}}`, encodeURIComponent(String(atsu)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of SIGMET/AIRMETs for the specified ATSU for the specified date
         * @param {string} atsu ATSU identifier
         * @param {string} date Date (YYYY-MM-DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sigmetsByATSUByDate: async (atsu: string, date: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'atsu' is not null or undefined
            assertParamExists('sigmetsByATSUByDate', 'atsu', atsu)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('sigmetsByATSUByDate', 'date', date)
            const localVarPath = `/aviation/sigmets/{atsu}/{date}`
                .replace(`{${"atsu"}}`, encodeURIComponent(String(atsu)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest observation for a station
         * @param {string} stationId Observation station ID
         * @param {boolean} [requireQc] Require QC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationObservationLatest: async (stationId: string, requireQc?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('stationObservationLatest', 'stationId', stationId)
            const localVarPath = `/stations/{stationId}/observations/latest`
                .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (requireQc !== undefined) {
                localVarQueryParameter['require_qc'] = requireQc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of observations for a given station
         * @param {string} stationId Observation station ID
         * @param {string} [start] Start time
         * @param {string} [end] End time
         * @param {string} [cursor] Pagination cursor
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationObservationList: async (stationId: string, start?: string, end?: string, cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('stationObservationList', 'stationId', stationId)
            const localVarPath = `/stations/{stationId}/observations`
                .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single observation.
         * @param {string} stationId Observation station ID
         * @param {string} time Timestamp of requested observation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationObservationTime: async (stationId: string, time: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('stationObservationTime', 'stationId', stationId)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('stationObservationTime', 'time', time)
            const localVarPath = `/stations/{stationId}/observations/{time}`
                .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)))
                .replace(`{${"time"}}`, encodeURIComponent(String(time)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Terminal Aerodrome Forecast.
         * @param {string} stationId Observation station ID
         * @param {string} date Date (YYYY-MM-DD format)
         * @param {string} time Time (HHMM format). This time is always specified in UTC (Zulu) time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taf: async (stationId: string, date: string, time: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('taf', 'stationId', stationId)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('taf', 'date', date)
            // verify required parameter 'time' is not null or undefined
            assertParamExists('taf', 'time', time)
            const localVarPath = `/stations/{stationId}/tafs/{date}/{time}`
                .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)))
                .replace(`{${"time"}}`, encodeURIComponent(String(time)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Terminal Aerodrome Forecasts for the specified airport station.
         * @param {string} stationId Observation station ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tafs: async (stationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationId' is not null or undefined
            assertParamExists('tafs', 'stationId', stationId)
            const localVarPath = `/stations/{stationId}/tafs`
                .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata about a given zone
         * @param {NWSZoneType} type Zone type
         * @param {string} zoneId NWS public zone/county identifier
         * @param {string} [effective] Effective date/time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zone: async (type: NWSZoneType, zoneId: string, effective?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('zone', 'type', type)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('zone', 'zoneId', zoneId)
            const localVarPath = `/zones/{type}/{zoneId}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (effective !== undefined) {
                localVarQueryParameter['effective'] = (effective as any instanceof Date) ?
                    (effective as any).toISOString() :
                    effective;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current zone forecast for a given zone
         * @param {string} type Zone type
         * @param {string} zoneId NWS public zone/county identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneForecast: async (type: string, zoneId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('zoneForecast', 'type', type)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('zoneForecast', 'zoneId', zoneId)
            const localVarPath = `/zones/{type}/{zoneId}/forecast`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of zones
         * @param {Array<string>} [id] Zone ID (forecast or county)
         * @param {Array<AreaCode>} [area] State/marine area code
         * @param {Array<RegionCode>} [region] Region code
         * @param {Array<NWSZoneType>} [type] Zone type
         * @param {string} [point] Point (latitude,longitude)
         * @param {boolean} [includeGeometry] Include geometry in results (true/false)
         * @param {number} [limit] Limit
         * @param {string} [effective] Effective date/time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneList: async (id?: Array<string>, area?: Array<AreaCode>, region?: Array<RegionCode>, type?: Array<NWSZoneType>, point?: string, includeGeometry?: boolean, limit?: number, effective?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }

            if (area) {
                localVarQueryParameter['area'] = area.join(COLLECTION_FORMATS.csv);
            }

            if (region) {
                localVarQueryParameter['region'] = region.join(COLLECTION_FORMATS.csv);
            }

            if (type) {
                localVarQueryParameter['type'] = type.join(COLLECTION_FORMATS.csv);
            }

            if (point !== undefined) {
                localVarQueryParameter['point'] = point;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['include_geometry'] = includeGeometry;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (effective !== undefined) {
                localVarQueryParameter['effective'] = (effective as any instanceof Date) ?
                    (effective as any).toISOString() :
                    effective;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of zones of a given type
         * @param {NWSZoneType} type Zone type
         * @param {Array<string>} [id] Zone ID (forecast or county)
         * @param {Array<AreaCode>} [area] State/marine area code
         * @param {Array<RegionCode>} [region] Region code
         * @param {Array<NWSZoneType>} [type2] Zone type
         * @param {string} [point] Point (latitude,longitude)
         * @param {boolean} [includeGeometry] Include geometry in results (true/false)
         * @param {number} [limit] Limit
         * @param {string} [effective] Effective date/time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneListType: async (type: NWSZoneType, id?: Array<string>, area?: Array<AreaCode>, region?: Array<RegionCode>, type2?: Array<NWSZoneType>, point?: string, includeGeometry?: boolean, limit?: number, effective?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('zoneListType', 'type', type)
            const localVarPath = `/zones/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }

            if (area) {
                localVarQueryParameter['area'] = area.join(COLLECTION_FORMATS.csv);
            }

            if (region) {
                localVarQueryParameter['region'] = region.join(COLLECTION_FORMATS.csv);
            }

            if (type2) {
                localVarQueryParameter['type'] = type2.join(COLLECTION_FORMATS.csv);
            }

            if (point !== undefined) {
                localVarQueryParameter['point'] = point;
            }

            if (includeGeometry !== undefined) {
                localVarQueryParameter['include_geometry'] = includeGeometry;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (effective !== undefined) {
                localVarQueryParameter['effective'] = (effective as any instanceof Date) ?
                    (effective as any).toISOString() :
                    effective;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of observations for a given zone
         * @param {string} zoneId NWS public zone/county identifier
         * @param {string} [start] Start date/time
         * @param {string} [end] End date/time
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneObs: async (zoneId: string, start?: string, end?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('zoneObs', 'zoneId', zoneId)
            const localVarPath = `/zones/forecast/{zoneId}/observations`
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of observation stations for a given zone
         * @param {string} zoneId NWS public zone/county identifier
         * @param {number} [limit] Limit
         * @param {string} [cursor] Pagination cursor
         * @param {Array<ZoneStationsFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneStations: async (zoneId: string, limit?: number, cursor?: string, featureFlags?: Array<ZoneStationsFeatureFlagsEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('zoneStations', 'zoneId', zoneId)
            const localVarPath = `/zones/forecast/{zoneId}/stations`
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "API-Key", configuration)

            // authentication userAgent required
            await setApiKeyToObject(localVarHeaderParameter, "User-Agent", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            if (featureFlags) {
                let mapped = featureFlags.map(value => (<any>"Array<'obs_station_provider'>" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
                localVarHeaderParameter['Feature-Flags'] = mapped.join(COLLECTION_FORMATS["csv"]);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all currently active alerts
         * @param {Array<AlertsActiveStatusEnum>} [status] Status (actual, exercise, system, test, draft)
         * @param {Array<AlertsActiveMessageTypeEnum>} [messageType] Message type (alert, update, cancel)
         * @param {Array<string>} [event] Event name
         * @param {Array<string>} [code] Event code
         * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
         * @param {string} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
         * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
         * @param {AlertsActiveRegionTypeEnum} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
         * @param {Array<string>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
         * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
         * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
         * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsActive(status?: Array<AlertsActiveStatusEnum>, messageType?: Array<AlertsActiveMessageTypeEnum>, event?: Array<string>, code?: Array<string>, area?: Array<AreaCode>, point?: string, region?: Array<MarineRegionCode>, regionType?: AlertsActiveRegionTypeEnum, zone?: Array<string>, urgency?: Array<AlertUrgency>, severity?: Array<AlertSeverity>, certainty?: Array<AlertCertainty>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsActive(status, messageType, event, code, area, point, region, regionType, zone, urgency, severity, certainty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.alertsActive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns active alerts for the given area (state or marine area)
         * @param {AreaCode} area State/area ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsActiveArea(area: AreaCode, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsActiveArea(area, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.alertsActiveArea']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns info on the number of active alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsActiveCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertsActiveCount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsActiveCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.alertsActiveCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns active alerts for the given marine region
         * @param {MarineRegionCode} region Marine region ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsActiveRegion(region: MarineRegionCode, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsActiveRegion(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.alertsActiveRegion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns active alerts for the given NWS public zone or county
         * @param {string} zoneId NWS public zone/county identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsActiveZone(zoneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsActiveZone(zoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.alertsActiveZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all alerts
         * @param {boolean} [active] List only active alerts (use /alerts/active endpoints instead)
         * @param {string} [start] Start time
         * @param {string} [end] End time
         * @param {Array<AlertsQueryStatusEnum>} [status] Status (actual, exercise, system, test, draft)
         * @param {Array<AlertsQueryMessageTypeEnum>} [messageType] Message type (alert, update, cancel)
         * @param {Array<string>} [event] Event name
         * @param {Array<string>} [code] Event code
         * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
         * @param {string} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
         * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
         * @param {AlertsQueryRegionTypeEnum} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
         * @param {Array<string>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
         * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
         * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
         * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
         * @param {number} [limit] Limit
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsQuery(active?: boolean, start?: string, end?: string, status?: Array<AlertsQueryStatusEnum>, messageType?: Array<AlertsQueryMessageTypeEnum>, event?: Array<string>, code?: Array<string>, area?: Array<AreaCode>, point?: string, region?: Array<MarineRegionCode>, regionType?: AlertsQueryRegionTypeEnum, zone?: Array<string>, urgency?: Array<AlertUrgency>, severity?: Array<AlertSeverity>, certainty?: Array<AlertCertainty>, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsQuery(active, start, end, status, messageType, event, code, area, point, region, regionType, zone, urgency, severity, certainty, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.alertsQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific alert
         * @param {string} id Alert identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsSingle(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsSingle(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.alertsSingle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of alert types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertsTypes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.alertsTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of Center Weather Advisories from a CWSU
         * @param {NWSCenterWeatherServiceUnitId} cwsuId NWS CWSU ID
         * @param {string} date Date (YYYY-MM-DD format)
         * @param {number} sequence Sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwa(cwsuId: NWSCenterWeatherServiceUnitId, date: string, sequence: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CenterWeatherAdvisoryGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwa(cwsuId, date, sequence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cwa']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of Center Weather Advisories from a CWSU
         * @param {NWSCenterWeatherServiceUnitId} cwsuId NWS CWSU ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwas(cwsuId: NWSCenterWeatherServiceUnitId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CenterWeatherAdvisoryCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwas(cwsuId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cwas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a Center Weather Service Unit
         * @param {NWSCenterWeatherServiceUnitId} cwsuId NWS CWSU ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cwsu(cwsuId: NWSCenterWeatherServiceUnitId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Office>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cwsu(cwsuId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cwsu']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns glossary terms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glossary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Glossary200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glossary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.glossary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns raw numerical forecast data for a 2.5km grid area
         * @param {NWSForecastOfficeId} wfo Forecast office ID
         * @param {number} x Forecast grid X coordinate
         * @param {number} y Forecast grid Y coordinate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gridpoint(wfo: NWSForecastOfficeId, x: number, y: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GridpointGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gridpoint(wfo, x, y, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.gridpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a textual forecast for a 2.5km grid area
         * @param {NWSForecastOfficeId} wfo Forecast office ID
         * @param {number} x Forecast grid X coordinate
         * @param {number} y Forecast grid Y coordinate
         * @param {Array<GridpointForecastFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
         * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gridpointForecast(wfo: NWSForecastOfficeId, x: number, y: number, featureFlags?: Array<GridpointForecastFeatureFlagsEnum>, units?: GridpointForecastUnits, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gridpoint12hForecastGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gridpointForecast(wfo, x, y, featureFlags, units, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.gridpointForecast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a textual hourly forecast for a 2.5km grid area
         * @param {NWSForecastOfficeId} wfo Forecast office ID
         * @param {number} x Forecast grid X coordinate
         * @param {number} y Forecast grid Y coordinate
         * @param {Array<GridpointForecastHourlyFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
         * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gridpointForecastHourly(wfo: NWSForecastOfficeId, x: number, y: number, featureFlags?: Array<GridpointForecastHourlyFeatureFlagsEnum>, units?: GridpointForecastUnits, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GridpointHourlyForecastGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gridpointForecastHourly(wfo, x, y, featureFlags, units, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.gridpointForecastHourly']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of observation stations usable for a given 2.5km grid area
         * @param {NWSForecastOfficeId} wfo Forecast office ID
         * @param {number} x Forecast grid X coordinate
         * @param {number} y Forecast grid Y coordinate
         * @param {number} [limit] Limit
         * @param {Array<GridpointStationsFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gridpointStations(wfo: NWSForecastOfficeId, x: number, y: number, limit?: number, featureFlags?: Array<GridpointStationsFeatureFlagsEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationStationCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gridpointStations(wfo, x, y, limit, featureFlags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.gridpointStations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a forecast icon. Icon services in API are deprecated.
         * @param {string} set .
         * @param {string} timeOfDay .
         * @param {string} first .
         * @param {IconsSizeParameter} [size] Font size
         * @param {number} [fontsize] Font size
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async icons(set: string, timeOfDay: string, first: string, size?: IconsSizeParameter, fontsize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.icons(set, timeOfDay, first, size, fontsize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.icons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a forecast icon. Icon services in API are deprecated.
         * @param {string} set .
         * @param {string} timeOfDay .
         * @param {string} first .
         * @param {string} second .
         * @param {IconsSizeParameter} [size] Font size
         * @param {number} [fontsize] Font size
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async iconsDualCondition(set: string, timeOfDay: string, first: string, second: string, size?: IconsSizeParameter, fontsize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iconsDualCondition(set, timeOfDay, first, second, size, fontsize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.iconsDualCondition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async iconsSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IconsSummary200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iconsSummary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.iconsSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns latest text products of a given type for a given issuance location with product text
         * @param {string} typeId .
         * @param {string} locationId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async latestProductTypeLocation(typeId: string, locationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.latestProductTypeLocation(typeId, locationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.latestProductTypeLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of valid text product types for a given issuance location
         * @param {string} locationId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async locationProducts(locationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextProductTypeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.locationProducts(locationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.locationProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a given observation station
         * @param {string} stationId Observation station ID
         * @param {Array<ObsStationFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obsStation(stationId: string, featureFlags?: Array<ObsStationFeatureFlagsEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationStationGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obsStation(stationId, featureFlags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.obsStation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of observation stations.
         * @param {Array<string>} [id] Filter by observation station ID
         * @param {Array<AreaCode>} [state] Filter by state/marine area code
         * @param {number} [limit] Limit
         * @param {string} [cursor] Pagination cursor
         * @param {Array<ObsStationsFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obsStations(id?: Array<string>, state?: Array<AreaCode>, limit?: number, cursor?: string, featureFlags?: Array<ObsStationsFeatureFlagsEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationStationCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obsStations(id, state, limit, cursor, featureFlags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.obsStations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a NWS forecast office
         * @param {NWSOfficeId} officeId NWS office ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async office(officeId: NWSOfficeId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Office>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.office(officeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.office']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific news headline for a given NWS office
         * @param {NWSOfficeId} officeId NWS office ID
         * @param {string} headlineId Headline record ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async officeHeadline(officeId: NWSOfficeId, headlineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfficeHeadline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.officeHeadline(officeId, headlineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.officeHeadline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of news headlines for a given NWS office
         * @param {NWSOfficeId} officeId NWS office ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async officeHeadlines(officeId: NWSOfficeId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfficeHeadlineCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.officeHeadlines(officeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.officeHeadlines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a given latitude/longitude point
         * @param {number} latitude Latitude
         * @param {number} longitude Longitude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async point(latitude: number, longitude: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.point(latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.point']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns NOAA Weather Radio script for a latitude/longitude point
         * @param {number} latitude Latitude
         * @param {number} longitude Longitude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointRadio(latitude: number, longitude: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointRadio(latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.pointRadio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of observation stations for a given point
         * @param {number} latitude Latitude
         * @param {number} longitude Longitude
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async pointStations(latitude: number, longitude: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointStations(latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.pointStations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific text product
         * @param {string} productId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async product(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.product(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.product']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of valid text product issuance locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productLocations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextProductLocationCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productLocations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.productLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of valid text product types and codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextProductTypeCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.productTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of text products
         * @param {Array<string>} [location] Location id
         * @param {string} [start] Start time
         * @param {string} [end] End time
         * @param {Array<string>} [office] Issuing office
         * @param {Array<string>} [wmoid] WMO id code
         * @param {Array<string>} [type] Product code
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsQuery(location?: Array<string>, start?: string, end?: string, office?: Array<string>, wmoid?: Array<string>, type?: Array<string>, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextProductCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsQuery(location, start, end, office, wmoid, type, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.productsQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of text products of a given type
         * @param {string} typeId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsType(typeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextProductCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsType(typeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.productsType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of text products of a given type for a given issuance location
         * @param {string} typeId .
         * @param {string} locationId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsTypeLocation(typeId: string, locationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextProductCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsTypeLocation(typeId, locationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.productsTypeLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of valid text product issuance locations for a given product type
         * @param {string} typeId .
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsTypeLocations(typeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextProductLocationCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsTypeLocations(typeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.productsTypeLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a given radar wind profiler
         * @param {string} stationId Profiler station ID
         * @param {ISO8601Interval} [time] Time interval
         * @param {string} [interval] Averaging interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarProfiler(stationId: string, time?: ISO8601Interval, interval?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.radarProfiler(stationId, time, interval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.radarProfiler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a given radar queue
         * @param {string} host LDM host
         * @param {number} [limit] Record limit
         * @param {ISO8601Interval} [arrived] Range for arrival time
         * @param {ISO8601Interval} [created] Range for creation time
         * @param {ISO8601Interval} [published] Range for publish time
         * @param {string} [station] Station identifier
         * @param {string} [type] Record type
         * @param {string} [feed] Originating product feed
         * @param {number} [resolution] Resolution version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarQueue(host: string, limit?: number, arrived?: ISO8601Interval, created?: ISO8601Interval, published?: ISO8601Interval, station?: string, type?: string, feed?: string, resolution?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.radarQueue(host, limit, arrived, created, published, station, type, feed, resolution, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.radarQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a given radar server
         * @param {string} id Server ID
         * @param {string} [reportingHost] Show records from specific reporting host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarServer(id: string, reportingHost?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.radarServer(id, reportingHost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.radarServer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of radar servers
         * @param {string} [reportingHost] Show records from specific reporting host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarServers(reportingHost?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.radarServers(reportingHost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.radarServers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a given radar station
         * @param {string} stationId Radar station ID
         * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
         * @param {string} [host] Show latency info from specific LDM host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarStation(stationId: string, reportingHost?: string, host?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.radarStation(stationId, reportingHost, host, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.radarStation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a given radar station alarms
         * @param {string} stationId Radar station ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarStationAlarms(stationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.radarStationAlarms(stationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.radarStationAlarms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of radar stations
         * @param {Array<string>} [stationType] Limit results to a specific station type or types
         * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
         * @param {string} [host] Show latency info from specific LDM host
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarStations(stationType?: Array<string>, reportingHost?: string, host?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.radarStations(stationType, reportingHost, host, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.radarStations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
         * @param {SatelliteThumbnailsAreaEnum} area .
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async satelliteThumbnails(area: SatelliteThumbnailsAreaEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.satelliteThumbnails(area, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.satelliteThumbnails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific SIGMET/AIRMET
         * @param {string} atsu ATSU identifier
         * @param {string} date Date (YYYY-MM-DD format)
         * @param {string} time Time (HHMM format). This time is always specified in UTC (Zulu) time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sigmet(atsu: string, date: string, time: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigmetGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sigmet(atsu, date, time, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sigmet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of SIGMET/AIRMETs
         * @param {string} [start] Start time
         * @param {string} [end] End time
         * @param {string} [date] Date (YYYY-MM-DD format)
         * @param {string} [atsu] ATSU identifier
         * @param {string} [sequence] SIGMET sequence number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sigmetQuery(start?: string, end?: string, date?: string, atsu?: string, sequence?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigmetCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sigmetQuery(start, end, date, atsu, sequence, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sigmetQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of SIGMET/AIRMETs for the specified ATSU
         * @param {string} atsu ATSU identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sigmetsByATSU(atsu: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigmetCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sigmetsByATSU(atsu, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sigmetsByATSU']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of SIGMET/AIRMETs for the specified ATSU for the specified date
         * @param {string} atsu ATSU identifier
         * @param {string} date Date (YYYY-MM-DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sigmetsByATSUByDate(atsu: string, date: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigmetCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sigmetsByATSUByDate(atsu, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sigmetsByATSUByDate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the latest observation for a station
         * @param {string} stationId Observation station ID
         * @param {boolean} [requireQc] Require QC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stationObservationLatest(stationId: string, requireQc?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stationObservationLatest(stationId, requireQc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.stationObservationLatest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of observations for a given station
         * @param {string} stationId Observation station ID
         * @param {string} [start] Start time
         * @param {string} [end] End time
         * @param {string} [cursor] Pagination cursor
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stationObservationList(stationId: string, start?: string, end?: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stationObservationList(stationId, start, end, cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.stationObservationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single observation.
         * @param {string} stationId Observation station ID
         * @param {string} time Timestamp of requested observation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stationObservationTime(stationId: string, time: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stationObservationTime(stationId, time, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.stationObservationTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single Terminal Aerodrome Forecast.
         * @param {string} stationId Observation station ID
         * @param {string} date Date (YYYY-MM-DD format)
         * @param {string} time Time (HHMM format). This time is always specified in UTC (Zulu) time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taf(stationId: string, date: string, time: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taf(stationId, date, time, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.taf']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns Terminal Aerodrome Forecasts for the specified airport station.
         * @param {string} stationId Observation station ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tafs(stationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tafs(stationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.tafs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns metadata about a given zone
         * @param {NWSZoneType} type Zone type
         * @param {string} zoneId NWS public zone/county identifier
         * @param {string} [effective] Effective date/time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zone(type: NWSZoneType, zoneId: string, effective?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zone(type, zoneId, effective, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.zone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current zone forecast for a given zone
         * @param {string} type Zone type
         * @param {string} zoneId NWS public zone/county identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneForecast(type: string, zoneId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneForecastGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneForecast(type, zoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.zoneForecast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of zones
         * @param {Array<string>} [id] Zone ID (forecast or county)
         * @param {Array<AreaCode>} [area] State/marine area code
         * @param {Array<RegionCode>} [region] Region code
         * @param {Array<NWSZoneType>} [type] Zone type
         * @param {string} [point] Point (latitude,longitude)
         * @param {boolean} [includeGeometry] Include geometry in results (true/false)
         * @param {number} [limit] Limit
         * @param {string} [effective] Effective date/time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneList(id?: Array<string>, area?: Array<AreaCode>, region?: Array<RegionCode>, type?: Array<NWSZoneType>, point?: string, includeGeometry?: boolean, limit?: number, effective?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneList(id, area, region, type, point, includeGeometry, limit, effective, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.zoneList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of zones of a given type
         * @param {NWSZoneType} type Zone type
         * @param {Array<string>} [id] Zone ID (forecast or county)
         * @param {Array<AreaCode>} [area] State/marine area code
         * @param {Array<RegionCode>} [region] Region code
         * @param {Array<NWSZoneType>} [type2] Zone type
         * @param {string} [point] Point (latitude,longitude)
         * @param {boolean} [includeGeometry] Include geometry in results (true/false)
         * @param {number} [limit] Limit
         * @param {string} [effective] Effective date/time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneListType(type: NWSZoneType, id?: Array<string>, area?: Array<AreaCode>, region?: Array<RegionCode>, type2?: Array<NWSZoneType>, point?: string, includeGeometry?: boolean, limit?: number, effective?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneListType(type, id, area, region, type2, point, includeGeometry, limit, effective, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.zoneListType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of observations for a given zone
         * @param {string} zoneId NWS public zone/county identifier
         * @param {string} [start] Start date/time
         * @param {string} [end] End date/time
         * @param {number} [limit] Limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneObs(zoneId: string, start?: string, end?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneObs(zoneId, start, end, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.zoneObs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of observation stations for a given zone
         * @param {string} zoneId NWS public zone/county identifier
         * @param {number} [limit] Limit
         * @param {string} [cursor] Pagination cursor
         * @param {Array<ZoneStationsFeatureFlagsEnum>} [featureFlags] Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneStations(zoneId: string, limit?: number, cursor?: string, featureFlags?: Array<ZoneStationsFeatureFlagsEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObservationStationCollectionGeoJson>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneStations(zoneId, limit, cursor, featureFlags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.zoneStations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Returns all currently active alerts
         * @param {DefaultApiAlertsActiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActive(requestParameters: DefaultApiAlertsActiveRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AlertCollectionGeoJson> {
            return localVarFp.alertsActive(requestParameters.status, requestParameters.messageType, requestParameters.event, requestParameters.code, requestParameters.area, requestParameters.point, requestParameters.region, requestParameters.regionType, requestParameters.zone, requestParameters.urgency, requestParameters.severity, requestParameters.certainty, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns active alerts for the given area (state or marine area)
         * @param {DefaultApiAlertsActiveAreaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActiveArea(requestParameters: DefaultApiAlertsActiveAreaRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlertCollectionGeoJson> {
            return localVarFp.alertsActiveArea(requestParameters.area, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns info on the number of active alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActiveCount(options?: RawAxiosRequestConfig): AxiosPromise<AlertsActiveCount200Response> {
            return localVarFp.alertsActiveCount(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns active alerts for the given marine region
         * @param {DefaultApiAlertsActiveRegionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActiveRegion(requestParameters: DefaultApiAlertsActiveRegionRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlertCollectionGeoJson> {
            return localVarFp.alertsActiveRegion(requestParameters.region, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns active alerts for the given NWS public zone or county
         * @param {DefaultApiAlertsActiveZoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsActiveZone(requestParameters: DefaultApiAlertsActiveZoneRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlertCollectionGeoJson> {
            return localVarFp.alertsActiveZone(requestParameters.zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all alerts
         * @param {DefaultApiAlertsQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsQuery(requestParameters: DefaultApiAlertsQueryRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AlertCollectionGeoJson> {
            return localVarFp.alertsQuery(requestParameters.active, requestParameters.start, requestParameters.end, requestParameters.status, requestParameters.messageType, requestParameters.event, requestParameters.code, requestParameters.area, requestParameters.point, requestParameters.region, requestParameters.regionType, requestParameters.zone, requestParameters.urgency, requestParameters.severity, requestParameters.certainty, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific alert
         * @param {DefaultApiAlertsSingleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsSingle(requestParameters: DefaultApiAlertsSingleRequest, options?: RawAxiosRequestConfig): AxiosPromise<AlertGeoJson> {
            return localVarFp.alertsSingle(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of alert types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsTypes(options?: RawAxiosRequestConfig): AxiosPromise<AlertsTypes200Response> {
            return localVarFp.alertsTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Center Weather Advisories from a CWSU
         * @param {DefaultApiCwaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwa(requestParameters: DefaultApiCwaRequest, options?: RawAxiosRequestConfig): AxiosPromise<CenterWeatherAdvisoryGeoJson> {
            return localVarFp.cwa(requestParameters.cwsuId, requestParameters.date, requestParameters.sequence, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Center Weather Advisories from a CWSU
         * @param {DefaultApiCwasRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwas(requestParameters: DefaultApiCwasRequest, options?: RawAxiosRequestConfig): AxiosPromise<CenterWeatherAdvisoryCollectionGeoJson> {
            return localVarFp.cwas(requestParameters.cwsuId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a Center Weather Service Unit
         * @param {DefaultApiCwsuRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cwsu(requestParameters: DefaultApiCwsuRequest, options?: RawAxiosRequestConfig): AxiosPromise<Office> {
            return localVarFp.cwsu(requestParameters.cwsuId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns glossary terms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glossary(options?: RawAxiosRequestConfig): AxiosPromise<Glossary200Response> {
            return localVarFp.glossary(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns raw numerical forecast data for a 2.5km grid area
         * @param {DefaultApiGridpointRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridpoint(requestParameters: DefaultApiGridpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<GridpointGeoJson> {
            return localVarFp.gridpoint(requestParameters.wfo, requestParameters.x, requestParameters.y, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a textual forecast for a 2.5km grid area
         * @param {DefaultApiGridpointForecastRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridpointForecast(requestParameters: DefaultApiGridpointForecastRequest, options?: RawAxiosRequestConfig): AxiosPromise<Gridpoint12hForecastGeoJson> {
            return localVarFp.gridpointForecast(requestParameters.wfo, requestParameters.x, requestParameters.y, requestParameters.featureFlags, requestParameters.units, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a textual hourly forecast for a 2.5km grid area
         * @param {DefaultApiGridpointForecastHourlyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridpointForecastHourly(requestParameters: DefaultApiGridpointForecastHourlyRequest, options?: RawAxiosRequestConfig): AxiosPromise<GridpointHourlyForecastGeoJson> {
            return localVarFp.gridpointForecastHourly(requestParameters.wfo, requestParameters.x, requestParameters.y, requestParameters.featureFlags, requestParameters.units, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of observation stations usable for a given 2.5km grid area
         * @param {DefaultApiGridpointStationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gridpointStations(requestParameters: DefaultApiGridpointStationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservationStationCollectionGeoJson> {
            return localVarFp.gridpointStations(requestParameters.wfo, requestParameters.x, requestParameters.y, requestParameters.limit, requestParameters.featureFlags, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a forecast icon. Icon services in API are deprecated.
         * @param {DefaultApiIconsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        icons(requestParameters: DefaultApiIconsRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.icons(requestParameters.set, requestParameters.timeOfDay, requestParameters.first, requestParameters.size, requestParameters.fontsize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a forecast icon. Icon services in API are deprecated.
         * @param {DefaultApiIconsDualConditionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iconsDualCondition(requestParameters: DefaultApiIconsDualConditionRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.iconsDualCondition(requestParameters.set, requestParameters.timeOfDay, requestParameters.first, requestParameters.second, requestParameters.size, requestParameters.fontsize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iconsSummary(options?: RawAxiosRequestConfig): AxiosPromise<IconsSummary200Response> {
            return localVarFp.iconsSummary(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns latest text products of a given type for a given issuance location with product text
         * @param {DefaultApiLatestProductTypeLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        latestProductTypeLocation(requestParameters: DefaultApiLatestProductTypeLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TextProduct> {
            return localVarFp.latestProductTypeLocation(requestParameters.typeId, requestParameters.locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of valid text product types for a given issuance location
         * @param {DefaultApiLocationProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        locationProducts(requestParameters: DefaultApiLocationProductsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TextProductTypeCollection> {
            return localVarFp.locationProducts(requestParameters.locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a given observation station
         * @param {DefaultApiObsStationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obsStation(requestParameters: DefaultApiObsStationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservationStationGeoJson> {
            return localVarFp.obsStation(requestParameters.stationId, requestParameters.featureFlags, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of observation stations.
         * @param {DefaultApiObsStationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obsStations(requestParameters: DefaultApiObsStationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ObservationStationCollectionGeoJson> {
            return localVarFp.obsStations(requestParameters.id, requestParameters.state, requestParameters.limit, requestParameters.cursor, requestParameters.featureFlags, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a NWS forecast office
         * @param {DefaultApiOfficeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        office(requestParameters: DefaultApiOfficeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Office> {
            return localVarFp.office(requestParameters.officeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific news headline for a given NWS office
         * @param {DefaultApiOfficeHeadlineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        officeHeadline(requestParameters: DefaultApiOfficeHeadlineRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfficeHeadline> {
            return localVarFp.officeHeadline(requestParameters.officeId, requestParameters.headlineId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of news headlines for a given NWS office
         * @param {DefaultApiOfficeHeadlinesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        officeHeadlines(requestParameters: DefaultApiOfficeHeadlinesRequest, options?: RawAxiosRequestConfig): AxiosPromise<OfficeHeadlineCollection> {
            return localVarFp.officeHeadlines(requestParameters.officeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a given latitude/longitude point
         * @param {DefaultApiPointRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        point(requestParameters: DefaultApiPointRequest, options?: RawAxiosRequestConfig): AxiosPromise<PointGeoJson> {
            return localVarFp.point(requestParameters.latitude, requestParameters.longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns NOAA Weather Radio script for a latitude/longitude point
         * @param {DefaultApiPointRadioRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointRadio(requestParameters: DefaultApiPointRadioRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.pointRadio(requestParameters.latitude, requestParameters.longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of observation stations for a given point
         * @param {DefaultApiPointStationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        pointStations(requestParameters: DefaultApiPointStationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProblemDetail> {
            return localVarFp.pointStations(requestParameters.latitude, requestParameters.longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific text product
         * @param {DefaultApiProductRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        product(requestParameters: DefaultApiProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<TextProduct> {
            return localVarFp.product(requestParameters.productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of valid text product issuance locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productLocations(options?: RawAxiosRequestConfig): AxiosPromise<TextProductLocationCollection> {
            return localVarFp.productLocations(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of valid text product types and codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTypes(options?: RawAxiosRequestConfig): AxiosPromise<TextProductTypeCollection> {
            return localVarFp.productTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of text products
         * @param {DefaultApiProductsQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsQuery(requestParameters: DefaultApiProductsQueryRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<TextProductCollection> {
            return localVarFp.productsQuery(requestParameters.location, requestParameters.start, requestParameters.end, requestParameters.office, requestParameters.wmoid, requestParameters.type, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of text products of a given type
         * @param {DefaultApiProductsTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsType(requestParameters: DefaultApiProductsTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<TextProductCollection> {
            return localVarFp.productsType(requestParameters.typeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of text products of a given type for a given issuance location
         * @param {DefaultApiProductsTypeLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsTypeLocation(requestParameters: DefaultApiProductsTypeLocationRequest, options?: RawAxiosRequestConfig): AxiosPromise<TextProductCollection> {
            return localVarFp.productsTypeLocation(requestParameters.typeId, requestParameters.locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of valid text product issuance locations for a given product type
         * @param {DefaultApiProductsTypeLocationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsTypeLocations(requestParameters: DefaultApiProductsTypeLocationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<TextProductLocationCollection> {
            return localVarFp.productsTypeLocations(requestParameters.typeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a given radar wind profiler
         * @param {DefaultApiRadarProfilerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarProfiler(requestParameters: DefaultApiRadarProfilerRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.radarProfiler(requestParameters.stationId, requestParameters.time, requestParameters.interval, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a given radar queue
         * @param {DefaultApiRadarQueueRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarQueue(requestParameters: DefaultApiRadarQueueRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.radarQueue(requestParameters.host, requestParameters.limit, requestParameters.arrived, requestParameters.created, requestParameters.published, requestParameters.station, requestParameters.type, requestParameters.feed, requestParameters.resolution, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a given radar server
         * @param {DefaultApiRadarServerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarServer(requestParameters: DefaultApiRadarServerRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.radarServer(requestParameters.id, requestParameters.reportingHost, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of radar servers
         * @param {DefaultApiRadarServersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarServers(requestParameters: DefaultApiRadarServersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.radarServers(requestParameters.reportingHost, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a given radar station
         * @param {DefaultApiRadarStationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarStation(requestParameters: DefaultApiRadarStationRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.radarStation(requestParameters.stationId, requestParameters.reportingHost, requestParameters.host, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a given radar station alarms
         * @param {DefaultApiRadarStationAlarmsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarStationAlarms(requestParameters: DefaultApiRadarStationAlarmsRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.radarStationAlarms(requestParameters.stationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of radar stations
         * @param {DefaultApiRadarStationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarStations(requestParameters: DefaultApiRadarStationsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.radarStations(requestParameters.stationType, requestParameters.reportingHost, requestParameters.host, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
         * @param {DefaultApiSatelliteThumbnailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        satelliteThumbnails(requestParameters: DefaultApiSatelliteThumbnailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.satelliteThumbnails(requestParameters.area, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific SIGMET/AIRMET
         * @param {DefaultApiSigmetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sigmet(requestParameters: DefaultApiSigmetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigmetGeoJson> {
            return localVarFp.sigmet(requestParameters.atsu, requestParameters.date, requestParameters.time, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of SIGMET/AIRMETs
         * @param {DefaultApiSigmetQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sigmetQuery(requestParameters: DefaultApiSigmetQueryRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SigmetCollectionGeoJson> {
            return localVarFp.sigmetQuery(requestParameters.start, requestParameters.end, requestParameters.date, requestParameters.atsu, requestParameters.sequence, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of SIGMET/AIRMETs for the specified ATSU
         * @param {DefaultApiSigmetsByATSURequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sigmetsByATSU(requestParameters: DefaultApiSigmetsByATSURequest, options?: RawAxiosRequestConfig): AxiosPromise<SigmetCollectionGeoJson> {
            return localVarFp.sigmetsByATSU(requestParameters.atsu, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of SIGMET/AIRMETs for the specified ATSU for the specified date
         * @param {DefaultApiSigmetsByATSUByDateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sigmetsByATSUByDate(requestParameters: DefaultApiSigmetsByATSUByDateRequest, options?: RawAxiosRequestConfig): AxiosPromise<SigmetCollectionGeoJson> {
            return localVarFp.sigmetsByATSUByDate(requestParameters.atsu, requestParameters.date, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest observation for a station
         * @param {DefaultApiStationObservationLatestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationObservationLatest(requestParameters: DefaultApiStationObservationLatestRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservationGeoJson> {
            return localVarFp.stationObservationLatest(requestParameters.stationId, requestParameters.requireQc, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of observations for a given station
         * @param {DefaultApiStationObservationListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationObservationList(requestParameters: DefaultApiStationObservationListRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservationCollectionGeoJson> {
            return localVarFp.stationObservationList(requestParameters.stationId, requestParameters.start, requestParameters.end, requestParameters.cursor, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single observation.
         * @param {DefaultApiStationObservationTimeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationObservationTime(requestParameters: DefaultApiStationObservationTimeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservationGeoJson> {
            return localVarFp.stationObservationTime(requestParameters.stationId, requestParameters.time, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Terminal Aerodrome Forecast.
         * @param {DefaultApiTafRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taf(requestParameters: DefaultApiTafRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.taf(requestParameters.stationId, requestParameters.date, requestParameters.time, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Terminal Aerodrome Forecasts for the specified airport station.
         * @param {DefaultApiTafsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tafs(requestParameters: DefaultApiTafsRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.tafs(requestParameters.stationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata about a given zone
         * @param {DefaultApiZoneRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zone(requestParameters: DefaultApiZoneRequest, options?: RawAxiosRequestConfig): AxiosPromise<ZoneGeoJson> {
            return localVarFp.zone(requestParameters.type, requestParameters.zoneId, requestParameters.effective, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current zone forecast for a given zone
         * @param {DefaultApiZoneForecastRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneForecast(requestParameters: DefaultApiZoneForecastRequest, options?: RawAxiosRequestConfig): AxiosPromise<ZoneForecastGeoJson> {
            return localVarFp.zoneForecast(requestParameters.type, requestParameters.zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of zones
         * @param {DefaultApiZoneListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneList(requestParameters: DefaultApiZoneListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ZoneCollectionGeoJson> {
            return localVarFp.zoneList(requestParameters.id, requestParameters.area, requestParameters.region, requestParameters.type, requestParameters.point, requestParameters.includeGeometry, requestParameters.limit, requestParameters.effective, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of zones of a given type
         * @param {DefaultApiZoneListTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneListType(requestParameters: DefaultApiZoneListTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ZoneCollectionGeoJson> {
            return localVarFp.zoneListType(requestParameters.type, requestParameters.id, requestParameters.area, requestParameters.region, requestParameters.type2, requestParameters.point, requestParameters.includeGeometry, requestParameters.limit, requestParameters.effective, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of observations for a given zone
         * @param {DefaultApiZoneObsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneObs(requestParameters: DefaultApiZoneObsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservationCollectionGeoJson> {
            return localVarFp.zoneObs(requestParameters.zoneId, requestParameters.start, requestParameters.end, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of observation stations for a given zone
         * @param {DefaultApiZoneStationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneStations(requestParameters: DefaultApiZoneStationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ObservationStationCollectionGeoJson> {
            return localVarFp.zoneStations(requestParameters.zoneId, requestParameters.limit, requestParameters.cursor, requestParameters.featureFlags, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for alertsActive operation in DefaultApi.
 */
export interface DefaultApiAlertsActiveRequest {
    /**
     * Status (actual, exercise, system, test, draft)
     */
    readonly status?: Array<AlertsActiveStatusEnum>

    /**
     * Message type (alert, update, cancel)
     */
    readonly messageType?: Array<AlertsActiveMessageTypeEnum>

    /**
     * Event name
     */
    readonly event?: Array<string>

    /**
     * Event code
     */
    readonly code?: Array<string>

    /**
     * State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
     */
    readonly area?: Array<AreaCode>

    /**
     * Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
     */
    readonly point?: string

    /**
     * Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
     */
    readonly region?: Array<MarineRegionCode>

    /**
     * Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
     */
    readonly regionType?: AlertsActiveRegionTypeEnum

    /**
     * Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
     */
    readonly zone?: Array<string>

    /**
     * Urgency (immediate, expected, future, past, unknown)
     */
    readonly urgency?: Array<AlertUrgency>

    /**
     * Severity (extreme, severe, moderate, minor, unknown)
     */
    readonly severity?: Array<AlertSeverity>

    /**
     * Certainty (observed, likely, possible, unlikely, unknown)
     */
    readonly certainty?: Array<AlertCertainty>
}

/**
 * Request parameters for alertsActiveArea operation in DefaultApi.
 */
export interface DefaultApiAlertsActiveAreaRequest {
    /**
     * State/area ID
     */
    readonly area: AreaCode
}

/**
 * Request parameters for alertsActiveRegion operation in DefaultApi.
 */
export interface DefaultApiAlertsActiveRegionRequest {
    /**
     * Marine region ID
     */
    readonly region: MarineRegionCode
}

/**
 * Request parameters for alertsActiveZone operation in DefaultApi.
 */
export interface DefaultApiAlertsActiveZoneRequest {
    /**
     * NWS public zone/county identifier
     */
    readonly zoneId: string
}

/**
 * Request parameters for alertsQuery operation in DefaultApi.
 */
export interface DefaultApiAlertsQueryRequest {
    /**
     * List only active alerts (use /alerts/active endpoints instead)
     */
    readonly active?: boolean

    /**
     * Start time
     */
    readonly start?: string

    /**
     * End time
     */
    readonly end?: string

    /**
     * Status (actual, exercise, system, test, draft)
     */
    readonly status?: Array<AlertsQueryStatusEnum>

    /**
     * Message type (alert, update, cancel)
     */
    readonly messageType?: Array<AlertsQueryMessageTypeEnum>

    /**
     * Event name
     */
    readonly event?: Array<string>

    /**
     * Event code
     */
    readonly code?: Array<string>

    /**
     * State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone 
     */
    readonly area?: Array<AreaCode>

    /**
     * Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone 
     */
    readonly point?: string

    /**
     * Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone 
     */
    readonly region?: Array<MarineRegionCode>

    /**
     * Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone 
     */
    readonly regionType?: AlertsQueryRegionTypeEnum

    /**
     * Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type 
     */
    readonly zone?: Array<string>

    /**
     * Urgency (immediate, expected, future, past, unknown)
     */
    readonly urgency?: Array<AlertUrgency>

    /**
     * Severity (extreme, severe, moderate, minor, unknown)
     */
    readonly severity?: Array<AlertSeverity>

    /**
     * Certainty (observed, likely, possible, unlikely, unknown)
     */
    readonly certainty?: Array<AlertCertainty>

    /**
     * Limit
     */
    readonly limit?: number

    /**
     * Pagination cursor
     */
    readonly cursor?: string
}

/**
 * Request parameters for alertsSingle operation in DefaultApi.
 */
export interface DefaultApiAlertsSingleRequest {
    /**
     * Alert identifier
     */
    readonly id: string
}

/**
 * Request parameters for cwa operation in DefaultApi.
 */
export interface DefaultApiCwaRequest {
    /**
     * NWS CWSU ID
     */
    readonly cwsuId: NWSCenterWeatherServiceUnitId

    /**
     * Date (YYYY-MM-DD format)
     */
    readonly date: string

    /**
     * Sequence number
     */
    readonly sequence: number
}

/**
 * Request parameters for cwas operation in DefaultApi.
 */
export interface DefaultApiCwasRequest {
    /**
     * NWS CWSU ID
     */
    readonly cwsuId: NWSCenterWeatherServiceUnitId
}

/**
 * Request parameters for cwsu operation in DefaultApi.
 */
export interface DefaultApiCwsuRequest {
    /**
     * NWS CWSU ID
     */
    readonly cwsuId: NWSCenterWeatherServiceUnitId
}

/**
 * Request parameters for gridpoint operation in DefaultApi.
 */
export interface DefaultApiGridpointRequest {
    /**
     * Forecast office ID
     */
    readonly wfo: NWSForecastOfficeId

    /**
     * Forecast grid X coordinate
     */
    readonly x: number

    /**
     * Forecast grid Y coordinate
     */
    readonly y: number
}

/**
 * Request parameters for gridpointForecast operation in DefaultApi.
 */
export interface DefaultApiGridpointForecastRequest {
    /**
     * Forecast office ID
     */
    readonly wfo: NWSForecastOfficeId

    /**
     * Forecast grid X coordinate
     */
    readonly x: number

    /**
     * Forecast grid Y coordinate
     */
    readonly y: number

    /**
     * Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
     */
    readonly featureFlags?: Array<GridpointForecastFeatureFlagsEnum>

    /**
     * Use US customary or SI (metric) units in textual output
     */
    readonly units?: GridpointForecastUnits
}

/**
 * Request parameters for gridpointForecastHourly operation in DefaultApi.
 */
export interface DefaultApiGridpointForecastHourlyRequest {
    /**
     * Forecast office ID
     */
    readonly wfo: NWSForecastOfficeId

    /**
     * Forecast grid X coordinate
     */
    readonly x: number

    /**
     * Forecast grid Y coordinate
     */
    readonly y: number

    /**
     * Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue 
     */
    readonly featureFlags?: Array<GridpointForecastHourlyFeatureFlagsEnum>

    /**
     * Use US customary or SI (metric) units in textual output
     */
    readonly units?: GridpointForecastUnits
}

/**
 * Request parameters for gridpointStations operation in DefaultApi.
 */
export interface DefaultApiGridpointStationsRequest {
    /**
     * Forecast office ID
     */
    readonly wfo: NWSForecastOfficeId

    /**
     * Forecast grid X coordinate
     */
    readonly x: number

    /**
     * Forecast grid Y coordinate
     */
    readonly y: number

    /**
     * Limit
     */
    readonly limit?: number

    /**
     * Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
     */
    readonly featureFlags?: Array<GridpointStationsFeatureFlagsEnum>
}

/**
 * Request parameters for icons operation in DefaultApi.
 */
export interface DefaultApiIconsRequest {
    /**
     * .
     */
    readonly set: string

    /**
     * .
     */
    readonly timeOfDay: string

    /**
     * .
     */
    readonly first: string

    /**
     * Font size
     */
    readonly size?: IconsSizeParameter

    /**
     * Font size
     */
    readonly fontsize?: number
}

/**
 * Request parameters for iconsDualCondition operation in DefaultApi.
 */
export interface DefaultApiIconsDualConditionRequest {
    /**
     * .
     */
    readonly set: string

    /**
     * .
     */
    readonly timeOfDay: string

    /**
     * .
     */
    readonly first: string

    /**
     * .
     */
    readonly second: string

    /**
     * Font size
     */
    readonly size?: IconsSizeParameter

    /**
     * Font size
     */
    readonly fontsize?: number
}

/**
 * Request parameters for latestProductTypeLocation operation in DefaultApi.
 */
export interface DefaultApiLatestProductTypeLocationRequest {
    /**
     * .
     */
    readonly typeId: string

    /**
     * .
     */
    readonly locationId: string
}

/**
 * Request parameters for locationProducts operation in DefaultApi.
 */
export interface DefaultApiLocationProductsRequest {
    /**
     * .
     */
    readonly locationId: string
}

/**
 * Request parameters for obsStation operation in DefaultApi.
 */
export interface DefaultApiObsStationRequest {
    /**
     * Observation station ID
     */
    readonly stationId: string

    /**
     * Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
     */
    readonly featureFlags?: Array<ObsStationFeatureFlagsEnum>
}

/**
 * Request parameters for obsStations operation in DefaultApi.
 */
export interface DefaultApiObsStationsRequest {
    /**
     * Filter by observation station ID
     */
    readonly id?: Array<string>

    /**
     * Filter by state/marine area code
     */
    readonly state?: Array<AreaCode>

    /**
     * Limit
     */
    readonly limit?: number

    /**
     * Pagination cursor
     */
    readonly cursor?: string

    /**
     * Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
     */
    readonly featureFlags?: Array<ObsStationsFeatureFlagsEnum>
}

/**
 * Request parameters for office operation in DefaultApi.
 */
export interface DefaultApiOfficeRequest {
    /**
     * NWS office ID
     */
    readonly officeId: NWSOfficeId
}

/**
 * Request parameters for officeHeadline operation in DefaultApi.
 */
export interface DefaultApiOfficeHeadlineRequest {
    /**
     * NWS office ID
     */
    readonly officeId: NWSOfficeId

    /**
     * Headline record ID
     */
    readonly headlineId: string
}

/**
 * Request parameters for officeHeadlines operation in DefaultApi.
 */
export interface DefaultApiOfficeHeadlinesRequest {
    /**
     * NWS office ID
     */
    readonly officeId: NWSOfficeId
}

/**
 * Request parameters for point operation in DefaultApi.
 */
export interface DefaultApiPointRequest {
    /**
     * Latitude
     */
    readonly latitude: number

    /**
     * Longitude
     */
    readonly longitude: number
}

/**
 * Request parameters for pointRadio operation in DefaultApi.
 */
export interface DefaultApiPointRadioRequest {
    /**
     * Latitude
     */
    readonly latitude: number

    /**
     * Longitude
     */
    readonly longitude: number
}

/**
 * Request parameters for pointStations operation in DefaultApi.
 */
export interface DefaultApiPointStationsRequest {
    /**
     * Latitude
     */
    readonly latitude: number

    /**
     * Longitude
     */
    readonly longitude: number
}

/**
 * Request parameters for product operation in DefaultApi.
 */
export interface DefaultApiProductRequest {
    /**
     * .
     */
    readonly productId: string
}

/**
 * Request parameters for productsQuery operation in DefaultApi.
 */
export interface DefaultApiProductsQueryRequest {
    /**
     * Location id
     */
    readonly location?: Array<string>

    /**
     * Start time
     */
    readonly start?: string

    /**
     * End time
     */
    readonly end?: string

    /**
     * Issuing office
     */
    readonly office?: Array<string>

    /**
     * WMO id code
     */
    readonly wmoid?: Array<string>

    /**
     * Product code
     */
    readonly type?: Array<string>

    /**
     * Limit
     */
    readonly limit?: number
}

/**
 * Request parameters for productsType operation in DefaultApi.
 */
export interface DefaultApiProductsTypeRequest {
    /**
     * .
     */
    readonly typeId: string
}

/**
 * Request parameters for productsTypeLocation operation in DefaultApi.
 */
export interface DefaultApiProductsTypeLocationRequest {
    /**
     * .
     */
    readonly typeId: string

    /**
     * .
     */
    readonly locationId: string
}

/**
 * Request parameters for productsTypeLocations operation in DefaultApi.
 */
export interface DefaultApiProductsTypeLocationsRequest {
    /**
     * .
     */
    readonly typeId: string
}

/**
 * Request parameters for radarProfiler operation in DefaultApi.
 */
export interface DefaultApiRadarProfilerRequest {
    /**
     * Profiler station ID
     */
    readonly stationId: string

    /**
     * Time interval
     */
    readonly time?: ISO8601Interval

    /**
     * Averaging interval
     */
    readonly interval?: string
}

/**
 * Request parameters for radarQueue operation in DefaultApi.
 */
export interface DefaultApiRadarQueueRequest {
    /**
     * LDM host
     */
    readonly host: string

    /**
     * Record limit
     */
    readonly limit?: number

    /**
     * Range for arrival time
     */
    readonly arrived?: ISO8601Interval

    /**
     * Range for creation time
     */
    readonly created?: ISO8601Interval

    /**
     * Range for publish time
     */
    readonly published?: ISO8601Interval

    /**
     * Station identifier
     */
    readonly station?: string

    /**
     * Record type
     */
    readonly type?: string

    /**
     * Originating product feed
     */
    readonly feed?: string

    /**
     * Resolution version
     */
    readonly resolution?: number
}

/**
 * Request parameters for radarServer operation in DefaultApi.
 */
export interface DefaultApiRadarServerRequest {
    /**
     * Server ID
     */
    readonly id: string

    /**
     * Show records from specific reporting host
     */
    readonly reportingHost?: string
}

/**
 * Request parameters for radarServers operation in DefaultApi.
 */
export interface DefaultApiRadarServersRequest {
    /**
     * Show records from specific reporting host
     */
    readonly reportingHost?: string
}

/**
 * Request parameters for radarStation operation in DefaultApi.
 */
export interface DefaultApiRadarStationRequest {
    /**
     * Radar station ID
     */
    readonly stationId: string

    /**
     * Show RDA and latency info from specific reporting host
     */
    readonly reportingHost?: string

    /**
     * Show latency info from specific LDM host
     */
    readonly host?: string
}

/**
 * Request parameters for radarStationAlarms operation in DefaultApi.
 */
export interface DefaultApiRadarStationAlarmsRequest {
    /**
     * Radar station ID
     */
    readonly stationId: string
}

/**
 * Request parameters for radarStations operation in DefaultApi.
 */
export interface DefaultApiRadarStationsRequest {
    /**
     * Limit results to a specific station type or types
     */
    readonly stationType?: Array<string>

    /**
     * Show RDA and latency info from specific reporting host
     */
    readonly reportingHost?: string

    /**
     * Show latency info from specific LDM host
     */
    readonly host?: string
}

/**
 * Request parameters for satelliteThumbnails operation in DefaultApi.
 */
export interface DefaultApiSatelliteThumbnailsRequest {
    /**
     * .
     */
    readonly area: SatelliteThumbnailsAreaEnum
}

/**
 * Request parameters for sigmet operation in DefaultApi.
 */
export interface DefaultApiSigmetRequest {
    /**
     * ATSU identifier
     */
    readonly atsu: string

    /**
     * Date (YYYY-MM-DD format)
     */
    readonly date: string

    /**
     * Time (HHMM format). This time is always specified in UTC (Zulu) time.
     */
    readonly time: string
}

/**
 * Request parameters for sigmetQuery operation in DefaultApi.
 */
export interface DefaultApiSigmetQueryRequest {
    /**
     * Start time
     */
    readonly start?: string

    /**
     * End time
     */
    readonly end?: string

    /**
     * Date (YYYY-MM-DD format)
     */
    readonly date?: string

    /**
     * ATSU identifier
     */
    readonly atsu?: string

    /**
     * SIGMET sequence number
     */
    readonly sequence?: string
}

/**
 * Request parameters for sigmetsByATSU operation in DefaultApi.
 */
export interface DefaultApiSigmetsByATSURequest {
    /**
     * ATSU identifier
     */
    readonly atsu: string
}

/**
 * Request parameters for sigmetsByATSUByDate operation in DefaultApi.
 */
export interface DefaultApiSigmetsByATSUByDateRequest {
    /**
     * ATSU identifier
     */
    readonly atsu: string

    /**
     * Date (YYYY-MM-DD format)
     */
    readonly date: string
}

/**
 * Request parameters for stationObservationLatest operation in DefaultApi.
 */
export interface DefaultApiStationObservationLatestRequest {
    /**
     * Observation station ID
     */
    readonly stationId: string

    /**
     * Require QC
     */
    readonly requireQc?: boolean
}

/**
 * Request parameters for stationObservationList operation in DefaultApi.
 */
export interface DefaultApiStationObservationListRequest {
    /**
     * Observation station ID
     */
    readonly stationId: string

    /**
     * Start time
     */
    readonly start?: string

    /**
     * End time
     */
    readonly end?: string

    /**
     * Pagination cursor
     */
    readonly cursor?: string

    /**
     * Limit
     */
    readonly limit?: number
}

/**
 * Request parameters for stationObservationTime operation in DefaultApi.
 */
export interface DefaultApiStationObservationTimeRequest {
    /**
     * Observation station ID
     */
    readonly stationId: string

    /**
     * Timestamp of requested observation
     */
    readonly time: string
}

/**
 * Request parameters for taf operation in DefaultApi.
 */
export interface DefaultApiTafRequest {
    /**
     * Observation station ID
     */
    readonly stationId: string

    /**
     * Date (YYYY-MM-DD format)
     */
    readonly date: string

    /**
     * Time (HHMM format). This time is always specified in UTC (Zulu) time.
     */
    readonly time: string
}

/**
 * Request parameters for tafs operation in DefaultApi.
 */
export interface DefaultApiTafsRequest {
    /**
     * Observation station ID
     */
    readonly stationId: string
}

/**
 * Request parameters for zone operation in DefaultApi.
 */
export interface DefaultApiZoneRequest {
    /**
     * Zone type
     */
    readonly type: NWSZoneType

    /**
     * NWS public zone/county identifier
     */
    readonly zoneId: string

    /**
     * Effective date/time
     */
    readonly effective?: string
}

/**
 * Request parameters for zoneForecast operation in DefaultApi.
 */
export interface DefaultApiZoneForecastRequest {
    /**
     * Zone type
     */
    readonly type: string

    /**
     * NWS public zone/county identifier
     */
    readonly zoneId: string
}

/**
 * Request parameters for zoneList operation in DefaultApi.
 */
export interface DefaultApiZoneListRequest {
    /**
     * Zone ID (forecast or county)
     */
    readonly id?: Array<string>

    /**
     * State/marine area code
     */
    readonly area?: Array<AreaCode>

    /**
     * Region code
     */
    readonly region?: Array<RegionCode>

    /**
     * Zone type
     */
    readonly type?: Array<NWSZoneType>

    /**
     * Point (latitude,longitude)
     */
    readonly point?: string

    /**
     * Include geometry in results (true/false)
     */
    readonly includeGeometry?: boolean

    /**
     * Limit
     */
    readonly limit?: number

    /**
     * Effective date/time
     */
    readonly effective?: string
}

/**
 * Request parameters for zoneListType operation in DefaultApi.
 */
export interface DefaultApiZoneListTypeRequest {
    /**
     * Zone type
     */
    readonly type: NWSZoneType

    /**
     * Zone ID (forecast or county)
     */
    readonly id?: Array<string>

    /**
     * State/marine area code
     */
    readonly area?: Array<AreaCode>

    /**
     * Region code
     */
    readonly region?: Array<RegionCode>

    /**
     * Zone type
     */
    readonly type2?: Array<NWSZoneType>

    /**
     * Point (latitude,longitude)
     */
    readonly point?: string

    /**
     * Include geometry in results (true/false)
     */
    readonly includeGeometry?: boolean

    /**
     * Limit
     */
    readonly limit?: number

    /**
     * Effective date/time
     */
    readonly effective?: string
}

/**
 * Request parameters for zoneObs operation in DefaultApi.
 */
export interface DefaultApiZoneObsRequest {
    /**
     * NWS public zone/county identifier
     */
    readonly zoneId: string

    /**
     * Start date/time
     */
    readonly start?: string

    /**
     * End date/time
     */
    readonly end?: string

    /**
     * Limit
     */
    readonly limit?: number
}

/**
 * Request parameters for zoneStations operation in DefaultApi.
 */
export interface DefaultApiZoneStationsRequest {
    /**
     * NWS public zone/county identifier
     */
    readonly zoneId: string

    /**
     * Limit
     */
    readonly limit?: number

    /**
     * Pagination cursor
     */
    readonly cursor?: string

    /**
     * Enable future and experimental features (see documentation for more info): * obs_station_provider: Include the data provider in the metadata about observation stations 
     */
    readonly featureFlags?: Array<ZoneStationsFeatureFlagsEnum>
}

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * Returns all currently active alerts
     * @param {DefaultApiAlertsActiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public alertsActive(requestParameters: DefaultApiAlertsActiveRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).alertsActive(requestParameters.status, requestParameters.messageType, requestParameters.event, requestParameters.code, requestParameters.area, requestParameters.point, requestParameters.region, requestParameters.regionType, requestParameters.zone, requestParameters.urgency, requestParameters.severity, requestParameters.certainty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns active alerts for the given area (state or marine area)
     * @param {DefaultApiAlertsActiveAreaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public alertsActiveArea(requestParameters: DefaultApiAlertsActiveAreaRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).alertsActiveArea(requestParameters.area, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns info on the number of active alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public alertsActiveCount(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).alertsActiveCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns active alerts for the given marine region
     * @param {DefaultApiAlertsActiveRegionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public alertsActiveRegion(requestParameters: DefaultApiAlertsActiveRegionRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).alertsActiveRegion(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns active alerts for the given NWS public zone or county
     * @param {DefaultApiAlertsActiveZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public alertsActiveZone(requestParameters: DefaultApiAlertsActiveZoneRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).alertsActiveZone(requestParameters.zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all alerts
     * @param {DefaultApiAlertsQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public alertsQuery(requestParameters: DefaultApiAlertsQueryRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).alertsQuery(requestParameters.active, requestParameters.start, requestParameters.end, requestParameters.status, requestParameters.messageType, requestParameters.event, requestParameters.code, requestParameters.area, requestParameters.point, requestParameters.region, requestParameters.regionType, requestParameters.zone, requestParameters.urgency, requestParameters.severity, requestParameters.certainty, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific alert
     * @param {DefaultApiAlertsSingleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public alertsSingle(requestParameters: DefaultApiAlertsSingleRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).alertsSingle(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of alert types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public alertsTypes(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).alertsTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Center Weather Advisories from a CWSU
     * @param {DefaultApiCwaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cwa(requestParameters: DefaultApiCwaRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cwa(requestParameters.cwsuId, requestParameters.date, requestParameters.sequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Center Weather Advisories from a CWSU
     * @param {DefaultApiCwasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cwas(requestParameters: DefaultApiCwasRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cwas(requestParameters.cwsuId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a Center Weather Service Unit
     * @param {DefaultApiCwsuRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cwsu(requestParameters: DefaultApiCwsuRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cwsu(requestParameters.cwsuId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns glossary terms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public glossary(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).glossary(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns raw numerical forecast data for a 2.5km grid area
     * @param {DefaultApiGridpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public gridpoint(requestParameters: DefaultApiGridpointRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).gridpoint(requestParameters.wfo, requestParameters.x, requestParameters.y, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a textual forecast for a 2.5km grid area
     * @param {DefaultApiGridpointForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public gridpointForecast(requestParameters: DefaultApiGridpointForecastRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).gridpointForecast(requestParameters.wfo, requestParameters.x, requestParameters.y, requestParameters.featureFlags, requestParameters.units, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a textual hourly forecast for a 2.5km grid area
     * @param {DefaultApiGridpointForecastHourlyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public gridpointForecastHourly(requestParameters: DefaultApiGridpointForecastHourlyRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).gridpointForecastHourly(requestParameters.wfo, requestParameters.x, requestParameters.y, requestParameters.featureFlags, requestParameters.units, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of observation stations usable for a given 2.5km grid area
     * @param {DefaultApiGridpointStationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public gridpointStations(requestParameters: DefaultApiGridpointStationsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).gridpointStations(requestParameters.wfo, requestParameters.x, requestParameters.y, requestParameters.limit, requestParameters.featureFlags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     * @param {DefaultApiIconsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public icons(requestParameters: DefaultApiIconsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).icons(requestParameters.set, requestParameters.timeOfDay, requestParameters.first, requestParameters.size, requestParameters.fontsize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     * @param {DefaultApiIconsDualConditionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public iconsDualCondition(requestParameters: DefaultApiIconsDualConditionRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).iconsDualCondition(requestParameters.set, requestParameters.timeOfDay, requestParameters.first, requestParameters.second, requestParameters.size, requestParameters.fontsize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public iconsSummary(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).iconsSummary(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns latest text products of a given type for a given issuance location with product text
     * @param {DefaultApiLatestProductTypeLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public latestProductTypeLocation(requestParameters: DefaultApiLatestProductTypeLocationRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).latestProductTypeLocation(requestParameters.typeId, requestParameters.locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of valid text product types for a given issuance location
     * @param {DefaultApiLocationProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public locationProducts(requestParameters: DefaultApiLocationProductsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).locationProducts(requestParameters.locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a given observation station
     * @param {DefaultApiObsStationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obsStation(requestParameters: DefaultApiObsStationRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).obsStation(requestParameters.stationId, requestParameters.featureFlags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of observation stations.
     * @param {DefaultApiObsStationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public obsStations(requestParameters: DefaultApiObsStationsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).obsStations(requestParameters.id, requestParameters.state, requestParameters.limit, requestParameters.cursor, requestParameters.featureFlags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a NWS forecast office
     * @param {DefaultApiOfficeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public office(requestParameters: DefaultApiOfficeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).office(requestParameters.officeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific news headline for a given NWS office
     * @param {DefaultApiOfficeHeadlineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public officeHeadline(requestParameters: DefaultApiOfficeHeadlineRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).officeHeadline(requestParameters.officeId, requestParameters.headlineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of news headlines for a given NWS office
     * @param {DefaultApiOfficeHeadlinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public officeHeadlines(requestParameters: DefaultApiOfficeHeadlinesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).officeHeadlines(requestParameters.officeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a given latitude/longitude point
     * @param {DefaultApiPointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public point(requestParameters: DefaultApiPointRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).point(requestParameters.latitude, requestParameters.longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns NOAA Weather Radio script for a latitude/longitude point
     * @param {DefaultApiPointRadioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public pointRadio(requestParameters: DefaultApiPointRadioRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pointRadio(requestParameters.latitude, requestParameters.longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of observation stations for a given point
     * @param {DefaultApiPointStationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public pointStations(requestParameters: DefaultApiPointStationsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pointStations(requestParameters.latitude, requestParameters.longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific text product
     * @param {DefaultApiProductRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public product(requestParameters: DefaultApiProductRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).product(requestParameters.productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of valid text product issuance locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productLocations(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).productLocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of valid text product types and codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productTypes(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).productTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of text products
     * @param {DefaultApiProductsQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productsQuery(requestParameters: DefaultApiProductsQueryRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).productsQuery(requestParameters.location, requestParameters.start, requestParameters.end, requestParameters.office, requestParameters.wmoid, requestParameters.type, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of text products of a given type
     * @param {DefaultApiProductsTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productsType(requestParameters: DefaultApiProductsTypeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).productsType(requestParameters.typeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of text products of a given type for a given issuance location
     * @param {DefaultApiProductsTypeLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productsTypeLocation(requestParameters: DefaultApiProductsTypeLocationRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).productsTypeLocation(requestParameters.typeId, requestParameters.locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of valid text product issuance locations for a given product type
     * @param {DefaultApiProductsTypeLocationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public productsTypeLocations(requestParameters: DefaultApiProductsTypeLocationsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).productsTypeLocations(requestParameters.typeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a given radar wind profiler
     * @param {DefaultApiRadarProfilerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public radarProfiler(requestParameters: DefaultApiRadarProfilerRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).radarProfiler(requestParameters.stationId, requestParameters.time, requestParameters.interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a given radar queue
     * @param {DefaultApiRadarQueueRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public radarQueue(requestParameters: DefaultApiRadarQueueRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).radarQueue(requestParameters.host, requestParameters.limit, requestParameters.arrived, requestParameters.created, requestParameters.published, requestParameters.station, requestParameters.type, requestParameters.feed, requestParameters.resolution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a given radar server
     * @param {DefaultApiRadarServerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public radarServer(requestParameters: DefaultApiRadarServerRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).radarServer(requestParameters.id, requestParameters.reportingHost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of radar servers
     * @param {DefaultApiRadarServersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public radarServers(requestParameters: DefaultApiRadarServersRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).radarServers(requestParameters.reportingHost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a given radar station
     * @param {DefaultApiRadarStationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public radarStation(requestParameters: DefaultApiRadarStationRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).radarStation(requestParameters.stationId, requestParameters.reportingHost, requestParameters.host, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a given radar station alarms
     * @param {DefaultApiRadarStationAlarmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public radarStationAlarms(requestParameters: DefaultApiRadarStationAlarmsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).radarStationAlarms(requestParameters.stationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of radar stations
     * @param {DefaultApiRadarStationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public radarStations(requestParameters: DefaultApiRadarStationsRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).radarStations(requestParameters.stationType, requestParameters.reportingHost, requestParameters.host, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
     * @param {DefaultApiSatelliteThumbnailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public satelliteThumbnails(requestParameters: DefaultApiSatelliteThumbnailsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).satelliteThumbnails(requestParameters.area, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific SIGMET/AIRMET
     * @param {DefaultApiSigmetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sigmet(requestParameters: DefaultApiSigmetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sigmet(requestParameters.atsu, requestParameters.date, requestParameters.time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of SIGMET/AIRMETs
     * @param {DefaultApiSigmetQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sigmetQuery(requestParameters: DefaultApiSigmetQueryRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sigmetQuery(requestParameters.start, requestParameters.end, requestParameters.date, requestParameters.atsu, requestParameters.sequence, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of SIGMET/AIRMETs for the specified ATSU
     * @param {DefaultApiSigmetsByATSURequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sigmetsByATSU(requestParameters: DefaultApiSigmetsByATSURequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sigmetsByATSU(requestParameters.atsu, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of SIGMET/AIRMETs for the specified ATSU for the specified date
     * @param {DefaultApiSigmetsByATSUByDateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sigmetsByATSUByDate(requestParameters: DefaultApiSigmetsByATSUByDateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sigmetsByATSUByDate(requestParameters.atsu, requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest observation for a station
     * @param {DefaultApiStationObservationLatestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public stationObservationLatest(requestParameters: DefaultApiStationObservationLatestRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stationObservationLatest(requestParameters.stationId, requestParameters.requireQc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of observations for a given station
     * @param {DefaultApiStationObservationListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public stationObservationList(requestParameters: DefaultApiStationObservationListRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stationObservationList(requestParameters.stationId, requestParameters.start, requestParameters.end, requestParameters.cursor, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single observation.
     * @param {DefaultApiStationObservationTimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public stationObservationTime(requestParameters: DefaultApiStationObservationTimeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).stationObservationTime(requestParameters.stationId, requestParameters.time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Terminal Aerodrome Forecast.
     * @param {DefaultApiTafRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public taf(requestParameters: DefaultApiTafRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).taf(requestParameters.stationId, requestParameters.date, requestParameters.time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Terminal Aerodrome Forecasts for the specified airport station.
     * @param {DefaultApiTafsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tafs(requestParameters: DefaultApiTafsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tafs(requestParameters.stationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata about a given zone
     * @param {DefaultApiZoneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zone(requestParameters: DefaultApiZoneRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).zone(requestParameters.type, requestParameters.zoneId, requestParameters.effective, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current zone forecast for a given zone
     * @param {DefaultApiZoneForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneForecast(requestParameters: DefaultApiZoneForecastRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).zoneForecast(requestParameters.type, requestParameters.zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of zones
     * @param {DefaultApiZoneListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneList(requestParameters: DefaultApiZoneListRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).zoneList(requestParameters.id, requestParameters.area, requestParameters.region, requestParameters.type, requestParameters.point, requestParameters.includeGeometry, requestParameters.limit, requestParameters.effective, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of zones of a given type
     * @param {DefaultApiZoneListTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneListType(requestParameters: DefaultApiZoneListTypeRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).zoneListType(requestParameters.type, requestParameters.id, requestParameters.area, requestParameters.region, requestParameters.type2, requestParameters.point, requestParameters.includeGeometry, requestParameters.limit, requestParameters.effective, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of observations for a given zone
     * @param {DefaultApiZoneObsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneObs(requestParameters: DefaultApiZoneObsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).zoneObs(requestParameters.zoneId, requestParameters.start, requestParameters.end, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of observation stations for a given zone
     * @param {DefaultApiZoneStationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneStations(requestParameters: DefaultApiZoneStationsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).zoneStations(requestParameters.zoneId, requestParameters.limit, requestParameters.cursor, requestParameters.featureFlags, options).then((request) => request(this.axios, this.basePath));
    }
}

export const AlertsActiveStatusEnum = {
    Actual: 'actual',
    Exercise: 'exercise',
    System: 'system',
    Test: 'test',
    Draft: 'draft'
} as const;
export type AlertsActiveStatusEnum = typeof AlertsActiveStatusEnum[keyof typeof AlertsActiveStatusEnum];
export const AlertsActiveMessageTypeEnum = {
    Alert: 'alert',
    Update: 'update',
    Cancel: 'cancel'
} as const;
export type AlertsActiveMessageTypeEnum = typeof AlertsActiveMessageTypeEnum[keyof typeof AlertsActiveMessageTypeEnum];
export const AlertsActiveRegionTypeEnum = {
    Land: 'land',
    Marine: 'marine'
} as const;
export type AlertsActiveRegionTypeEnum = typeof AlertsActiveRegionTypeEnum[keyof typeof AlertsActiveRegionTypeEnum];
export const AlertsQueryStatusEnum = {
    Actual: 'actual',
    Exercise: 'exercise',
    System: 'system',
    Test: 'test',
    Draft: 'draft'
} as const;
export type AlertsQueryStatusEnum = typeof AlertsQueryStatusEnum[keyof typeof AlertsQueryStatusEnum];
export const AlertsQueryMessageTypeEnum = {
    Alert: 'alert',
    Update: 'update',
    Cancel: 'cancel'
} as const;
export type AlertsQueryMessageTypeEnum = typeof AlertsQueryMessageTypeEnum[keyof typeof AlertsQueryMessageTypeEnum];
export const AlertsQueryRegionTypeEnum = {
    Land: 'land',
    Marine: 'marine'
} as const;
export type AlertsQueryRegionTypeEnum = typeof AlertsQueryRegionTypeEnum[keyof typeof AlertsQueryRegionTypeEnum];
export const GridpointForecastFeatureFlagsEnum = {
    ForecastTemperatureQv: 'forecast_temperature_qv',
    ForecastWindSpeedQv: 'forecast_wind_speed_qv'
} as const;
export type GridpointForecastFeatureFlagsEnum = typeof GridpointForecastFeatureFlagsEnum[keyof typeof GridpointForecastFeatureFlagsEnum];
export const GridpointForecastHourlyFeatureFlagsEnum = {
    ForecastTemperatureQv: 'forecast_temperature_qv',
    ForecastWindSpeedQv: 'forecast_wind_speed_qv'
} as const;
export type GridpointForecastHourlyFeatureFlagsEnum = typeof GridpointForecastHourlyFeatureFlagsEnum[keyof typeof GridpointForecastHourlyFeatureFlagsEnum];
export const GridpointStationsFeatureFlagsEnum = {
    ObsStationProvider: 'obs_station_provider'
} as const;
export type GridpointStationsFeatureFlagsEnum = typeof GridpointStationsFeatureFlagsEnum[keyof typeof GridpointStationsFeatureFlagsEnum];
export const ObsStationFeatureFlagsEnum = {
    ObsStationProvider: 'obs_station_provider'
} as const;
export type ObsStationFeatureFlagsEnum = typeof ObsStationFeatureFlagsEnum[keyof typeof ObsStationFeatureFlagsEnum];
export const ObsStationsFeatureFlagsEnum = {
    ObsStationProvider: 'obs_station_provider'
} as const;
export type ObsStationsFeatureFlagsEnum = typeof ObsStationsFeatureFlagsEnum[keyof typeof ObsStationsFeatureFlagsEnum];
export const SatelliteThumbnailsAreaEnum = {
    A: 'a',
    E: 'e',
    G: 'g',
    H: 'h',
    P: 'p',
    S: 's',
    W: 'w'
} as const;
export type SatelliteThumbnailsAreaEnum = typeof SatelliteThumbnailsAreaEnum[keyof typeof SatelliteThumbnailsAreaEnum];
export const ZoneStationsFeatureFlagsEnum = {
    ObsStationProvider: 'obs_station_provider'
} as const;
export type ZoneStationsFeatureFlagsEnum = typeof ZoneStationsFeatureFlagsEnum[keyof typeof ZoneStationsFeatureFlagsEnum];
